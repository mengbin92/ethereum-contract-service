// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: erc721/v1/erc721.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ERC721_GetERC721Balance_FullMethodName           = "/api.erc721.v1.ERC721/GetERC721Balance"
	ERC721_GetERC721TokenInfo_FullMethodName         = "/api.erc721.v1.ERC721/GetERC721TokenInfo"
	ERC721_GetERC721TokenURI_FullMethodName          = "/api.erc721.v1.ERC721/GetERC721TokenURI"
	ERC721_GetERC721OwnerOf_FullMethodName           = "/api.erc721.v1.ERC721/GetERC721OwnerOf"
	ERC721_GetERC721Approved_FullMethodName          = "/api.erc721.v1.ERC721/GetERC721Approved"
	ERC721_IsApprovedForAllERC721_FullMethodName     = "/api.erc721.v1.ERC721/IsApprovedForAllERC721"
	ERC721_TransferERC721_FullMethodName             = "/api.erc721.v1.ERC721/TransferERC721"
	ERC721_SafeTransferERC721_FullMethodName         = "/api.erc721.v1.ERC721/SafeTransferERC721"
	ERC721_SafeTransferERC721WithData_FullMethodName = "/api.erc721.v1.ERC721/SafeTransferERC721WithData"
	ERC721_ApproveERC721_FullMethodName              = "/api.erc721.v1.ERC721/ApproveERC721"
	ERC721_SetApprovalForAllERC721_FullMethodName    = "/api.erc721.v1.ERC721/SetApprovalForAllERC721"
	ERC721_SafeMintERC721_FullMethodName             = "/api.erc721.v1.ERC721/SafeMintERC721"
	ERC721_BurnERC721_FullMethodName                 = "/api.erc721.v1.ERC721/BurnERC721"
	ERC721_DeployERC721_FullMethodName               = "/api.erc721.v1.ERC721/DeployERC721"
)

// ERC721Client is the client API for ERC721 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ERC721 service provides ERC721 (NFT) token interaction endpoints
type ERC721Client interface {
	// GetERC721Balance returns the ERC721 token balance (number of NFTs) of the specified address
	GetERC721Balance(ctx context.Context, in *GetERC721BalanceRequest, opts ...grpc.CallOption) (*GetERC721BalanceResponse, error)
	// GetERC721TokenInfo returns ERC721 token information (name, symbol)
	GetERC721TokenInfo(ctx context.Context, in *GetERC721TokenInfoRequest, opts ...grpc.CallOption) (*GetERC721TokenInfoResponse, error)
	// GetERC721TokenURI returns the URI for a specific token
	GetERC721TokenURI(ctx context.Context, in *GetERC721TokenURIRequest, opts ...grpc.CallOption) (*GetERC721TokenURIResponse, error)
	// GetERC721OwnerOf returns the owner of a specific token
	GetERC721OwnerOf(ctx context.Context, in *GetERC721OwnerOfRequest, opts ...grpc.CallOption) (*GetERC721OwnerOfResponse, error)
	// GetERC721Approved returns the approved address for a token
	GetERC721Approved(ctx context.Context, in *GetERC721ApprovedRequest, opts ...grpc.CallOption) (*GetERC721ApprovedResponse, error)
	// IsApprovedForAllERC721 checks if an operator is approved for all tokens of an owner
	IsApprovedForAllERC721(ctx context.Context, in *IsApprovedForAllERC721Request, opts ...grpc.CallOption) (*IsApprovedForAllERC721Response, error)
	// TransferERC721 transfers an ERC721 token from the caller to the specified address
	TransferERC721(ctx context.Context, in *TransferERC721Request, opts ...grpc.CallOption) (*TransferERC721Response, error)
	// SafeTransferERC721 safely transfers an ERC721 token (calls onERC721Received on recipient)
	SafeTransferERC721(ctx context.Context, in *SafeTransferERC721Request, opts ...grpc.CallOption) (*SafeTransferERC721Response, error)
	// SafeTransferERC721WithData safely transfers an ERC721 token with additional data
	SafeTransferERC721WithData(ctx context.Context, in *SafeTransferERC721WithDataRequest, opts ...grpc.CallOption) (*SafeTransferERC721WithDataResponse, error)
	// ApproveERC721 approves another address to transfer the specified token
	ApproveERC721(ctx context.Context, in *ApproveERC721Request, opts ...grpc.CallOption) (*ApproveERC721Response, error)
	// SetApprovalForAllERC721 enables or disables approval for a third party ("operator") to manage all tokens
	SetApprovalForAllERC721(ctx context.Context, in *SetApprovalForAllERC721Request, opts ...grpc.CallOption) (*SetApprovalForAllERC721Response, error)
	// SafeMintERC721 safely mints a new ERC721 token
	SafeMintERC721(ctx context.Context, in *SafeMintERC721Request, opts ...grpc.CallOption) (*SafeMintERC721Response, error)
	// BurnERC721 burns an ERC721 token
	BurnERC721(ctx context.Context, in *BurnERC721Request, opts ...grpc.CallOption) (*BurnERC721Response, error)
	// DeployERC721 deploys a new ERC721 token contract
	DeployERC721(ctx context.Context, in *DeployERC721Request, opts ...grpc.CallOption) (*DeployERC721Response, error)
}

type eRC721Client struct {
	cc grpc.ClientConnInterface
}

func NewERC721Client(cc grpc.ClientConnInterface) ERC721Client {
	return &eRC721Client{cc}
}

func (c *eRC721Client) GetERC721Balance(ctx context.Context, in *GetERC721BalanceRequest, opts ...grpc.CallOption) (*GetERC721BalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC721BalanceResponse)
	err := c.cc.Invoke(ctx, ERC721_GetERC721Balance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) GetERC721TokenInfo(ctx context.Context, in *GetERC721TokenInfoRequest, opts ...grpc.CallOption) (*GetERC721TokenInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC721TokenInfoResponse)
	err := c.cc.Invoke(ctx, ERC721_GetERC721TokenInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) GetERC721TokenURI(ctx context.Context, in *GetERC721TokenURIRequest, opts ...grpc.CallOption) (*GetERC721TokenURIResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC721TokenURIResponse)
	err := c.cc.Invoke(ctx, ERC721_GetERC721TokenURI_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) GetERC721OwnerOf(ctx context.Context, in *GetERC721OwnerOfRequest, opts ...grpc.CallOption) (*GetERC721OwnerOfResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC721OwnerOfResponse)
	err := c.cc.Invoke(ctx, ERC721_GetERC721OwnerOf_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) GetERC721Approved(ctx context.Context, in *GetERC721ApprovedRequest, opts ...grpc.CallOption) (*GetERC721ApprovedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC721ApprovedResponse)
	err := c.cc.Invoke(ctx, ERC721_GetERC721Approved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) IsApprovedForAllERC721(ctx context.Context, in *IsApprovedForAllERC721Request, opts ...grpc.CallOption) (*IsApprovedForAllERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsApprovedForAllERC721Response)
	err := c.cc.Invoke(ctx, ERC721_IsApprovedForAllERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) TransferERC721(ctx context.Context, in *TransferERC721Request, opts ...grpc.CallOption) (*TransferERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferERC721Response)
	err := c.cc.Invoke(ctx, ERC721_TransferERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) SafeTransferERC721(ctx context.Context, in *SafeTransferERC721Request, opts ...grpc.CallOption) (*SafeTransferERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SafeTransferERC721Response)
	err := c.cc.Invoke(ctx, ERC721_SafeTransferERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) SafeTransferERC721WithData(ctx context.Context, in *SafeTransferERC721WithDataRequest, opts ...grpc.CallOption) (*SafeTransferERC721WithDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SafeTransferERC721WithDataResponse)
	err := c.cc.Invoke(ctx, ERC721_SafeTransferERC721WithData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) ApproveERC721(ctx context.Context, in *ApproveERC721Request, opts ...grpc.CallOption) (*ApproveERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveERC721Response)
	err := c.cc.Invoke(ctx, ERC721_ApproveERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) SetApprovalForAllERC721(ctx context.Context, in *SetApprovalForAllERC721Request, opts ...grpc.CallOption) (*SetApprovalForAllERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetApprovalForAllERC721Response)
	err := c.cc.Invoke(ctx, ERC721_SetApprovalForAllERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) SafeMintERC721(ctx context.Context, in *SafeMintERC721Request, opts ...grpc.CallOption) (*SafeMintERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SafeMintERC721Response)
	err := c.cc.Invoke(ctx, ERC721_SafeMintERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) BurnERC721(ctx context.Context, in *BurnERC721Request, opts ...grpc.CallOption) (*BurnERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BurnERC721Response)
	err := c.cc.Invoke(ctx, ERC721_BurnERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC721Client) DeployERC721(ctx context.Context, in *DeployERC721Request, opts ...grpc.CallOption) (*DeployERC721Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeployERC721Response)
	err := c.cc.Invoke(ctx, ERC721_DeployERC721_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ERC721Server is the server API for ERC721 service.
// All implementations must embed UnimplementedERC721Server
// for forward compatibility.
//
// ERC721 service provides ERC721 (NFT) token interaction endpoints
type ERC721Server interface {
	// GetERC721Balance returns the ERC721 token balance (number of NFTs) of the specified address
	GetERC721Balance(context.Context, *GetERC721BalanceRequest) (*GetERC721BalanceResponse, error)
	// GetERC721TokenInfo returns ERC721 token information (name, symbol)
	GetERC721TokenInfo(context.Context, *GetERC721TokenInfoRequest) (*GetERC721TokenInfoResponse, error)
	// GetERC721TokenURI returns the URI for a specific token
	GetERC721TokenURI(context.Context, *GetERC721TokenURIRequest) (*GetERC721TokenURIResponse, error)
	// GetERC721OwnerOf returns the owner of a specific token
	GetERC721OwnerOf(context.Context, *GetERC721OwnerOfRequest) (*GetERC721OwnerOfResponse, error)
	// GetERC721Approved returns the approved address for a token
	GetERC721Approved(context.Context, *GetERC721ApprovedRequest) (*GetERC721ApprovedResponse, error)
	// IsApprovedForAllERC721 checks if an operator is approved for all tokens of an owner
	IsApprovedForAllERC721(context.Context, *IsApprovedForAllERC721Request) (*IsApprovedForAllERC721Response, error)
	// TransferERC721 transfers an ERC721 token from the caller to the specified address
	TransferERC721(context.Context, *TransferERC721Request) (*TransferERC721Response, error)
	// SafeTransferERC721 safely transfers an ERC721 token (calls onERC721Received on recipient)
	SafeTransferERC721(context.Context, *SafeTransferERC721Request) (*SafeTransferERC721Response, error)
	// SafeTransferERC721WithData safely transfers an ERC721 token with additional data
	SafeTransferERC721WithData(context.Context, *SafeTransferERC721WithDataRequest) (*SafeTransferERC721WithDataResponse, error)
	// ApproveERC721 approves another address to transfer the specified token
	ApproveERC721(context.Context, *ApproveERC721Request) (*ApproveERC721Response, error)
	// SetApprovalForAllERC721 enables or disables approval for a third party ("operator") to manage all tokens
	SetApprovalForAllERC721(context.Context, *SetApprovalForAllERC721Request) (*SetApprovalForAllERC721Response, error)
	// SafeMintERC721 safely mints a new ERC721 token
	SafeMintERC721(context.Context, *SafeMintERC721Request) (*SafeMintERC721Response, error)
	// BurnERC721 burns an ERC721 token
	BurnERC721(context.Context, *BurnERC721Request) (*BurnERC721Response, error)
	// DeployERC721 deploys a new ERC721 token contract
	DeployERC721(context.Context, *DeployERC721Request) (*DeployERC721Response, error)
	mustEmbedUnimplementedERC721Server()
}

// UnimplementedERC721Server must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedERC721Server struct{}

func (UnimplementedERC721Server) GetERC721Balance(context.Context, *GetERC721BalanceRequest) (*GetERC721BalanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC721Balance not implemented")
}
func (UnimplementedERC721Server) GetERC721TokenInfo(context.Context, *GetERC721TokenInfoRequest) (*GetERC721TokenInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC721TokenInfo not implemented")
}
func (UnimplementedERC721Server) GetERC721TokenURI(context.Context, *GetERC721TokenURIRequest) (*GetERC721TokenURIResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC721TokenURI not implemented")
}
func (UnimplementedERC721Server) GetERC721OwnerOf(context.Context, *GetERC721OwnerOfRequest) (*GetERC721OwnerOfResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC721OwnerOf not implemented")
}
func (UnimplementedERC721Server) GetERC721Approved(context.Context, *GetERC721ApprovedRequest) (*GetERC721ApprovedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC721Approved not implemented")
}
func (UnimplementedERC721Server) IsApprovedForAllERC721(context.Context, *IsApprovedForAllERC721Request) (*IsApprovedForAllERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method IsApprovedForAllERC721 not implemented")
}
func (UnimplementedERC721Server) TransferERC721(context.Context, *TransferERC721Request) (*TransferERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method TransferERC721 not implemented")
}
func (UnimplementedERC721Server) SafeTransferERC721(context.Context, *SafeTransferERC721Request) (*SafeTransferERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method SafeTransferERC721 not implemented")
}
func (UnimplementedERC721Server) SafeTransferERC721WithData(context.Context, *SafeTransferERC721WithDataRequest) (*SafeTransferERC721WithDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SafeTransferERC721WithData not implemented")
}
func (UnimplementedERC721Server) ApproveERC721(context.Context, *ApproveERC721Request) (*ApproveERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method ApproveERC721 not implemented")
}
func (UnimplementedERC721Server) SetApprovalForAllERC721(context.Context, *SetApprovalForAllERC721Request) (*SetApprovalForAllERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method SetApprovalForAllERC721 not implemented")
}
func (UnimplementedERC721Server) SafeMintERC721(context.Context, *SafeMintERC721Request) (*SafeMintERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method SafeMintERC721 not implemented")
}
func (UnimplementedERC721Server) BurnERC721(context.Context, *BurnERC721Request) (*BurnERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method BurnERC721 not implemented")
}
func (UnimplementedERC721Server) DeployERC721(context.Context, *DeployERC721Request) (*DeployERC721Response, error) {
	return nil, status.Error(codes.Unimplemented, "method DeployERC721 not implemented")
}
func (UnimplementedERC721Server) mustEmbedUnimplementedERC721Server() {}
func (UnimplementedERC721Server) testEmbeddedByValue()                {}

// UnsafeERC721Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ERC721Server will
// result in compilation errors.
type UnsafeERC721Server interface {
	mustEmbedUnimplementedERC721Server()
}

func RegisterERC721Server(s grpc.ServiceRegistrar, srv ERC721Server) {
	// If the following call panics, it indicates UnimplementedERC721Server was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ERC721_ServiceDesc, srv)
}

func _ERC721_GetERC721Balance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC721BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).GetERC721Balance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_GetERC721Balance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).GetERC721Balance(ctx, req.(*GetERC721BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_GetERC721TokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC721TokenInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).GetERC721TokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_GetERC721TokenInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).GetERC721TokenInfo(ctx, req.(*GetERC721TokenInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_GetERC721TokenURI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC721TokenURIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).GetERC721TokenURI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_GetERC721TokenURI_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).GetERC721TokenURI(ctx, req.(*GetERC721TokenURIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_GetERC721OwnerOf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC721OwnerOfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).GetERC721OwnerOf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_GetERC721OwnerOf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).GetERC721OwnerOf(ctx, req.(*GetERC721OwnerOfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_GetERC721Approved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC721ApprovedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).GetERC721Approved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_GetERC721Approved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).GetERC721Approved(ctx, req.(*GetERC721ApprovedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_IsApprovedForAllERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsApprovedForAllERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).IsApprovedForAllERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_IsApprovedForAllERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).IsApprovedForAllERC721(ctx, req.(*IsApprovedForAllERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_TransferERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).TransferERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_TransferERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).TransferERC721(ctx, req.(*TransferERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_SafeTransferERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SafeTransferERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).SafeTransferERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_SafeTransferERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).SafeTransferERC721(ctx, req.(*SafeTransferERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_SafeTransferERC721WithData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SafeTransferERC721WithDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).SafeTransferERC721WithData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_SafeTransferERC721WithData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).SafeTransferERC721WithData(ctx, req.(*SafeTransferERC721WithDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_ApproveERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).ApproveERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_ApproveERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).ApproveERC721(ctx, req.(*ApproveERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_SetApprovalForAllERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetApprovalForAllERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).SetApprovalForAllERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_SetApprovalForAllERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).SetApprovalForAllERC721(ctx, req.(*SetApprovalForAllERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_SafeMintERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SafeMintERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).SafeMintERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_SafeMintERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).SafeMintERC721(ctx, req.(*SafeMintERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_BurnERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BurnERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).BurnERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_BurnERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).BurnERC721(ctx, req.(*BurnERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC721_DeployERC721_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployERC721Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC721Server).DeployERC721(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC721_DeployERC721_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC721Server).DeployERC721(ctx, req.(*DeployERC721Request))
	}
	return interceptor(ctx, in, info, handler)
}

// ERC721_ServiceDesc is the grpc.ServiceDesc for ERC721 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ERC721_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.erc721.v1.ERC721",
	HandlerType: (*ERC721Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetERC721Balance",
			Handler:    _ERC721_GetERC721Balance_Handler,
		},
		{
			MethodName: "GetERC721TokenInfo",
			Handler:    _ERC721_GetERC721TokenInfo_Handler,
		},
		{
			MethodName: "GetERC721TokenURI",
			Handler:    _ERC721_GetERC721TokenURI_Handler,
		},
		{
			MethodName: "GetERC721OwnerOf",
			Handler:    _ERC721_GetERC721OwnerOf_Handler,
		},
		{
			MethodName: "GetERC721Approved",
			Handler:    _ERC721_GetERC721Approved_Handler,
		},
		{
			MethodName: "IsApprovedForAllERC721",
			Handler:    _ERC721_IsApprovedForAllERC721_Handler,
		},
		{
			MethodName: "TransferERC721",
			Handler:    _ERC721_TransferERC721_Handler,
		},
		{
			MethodName: "SafeTransferERC721",
			Handler:    _ERC721_SafeTransferERC721_Handler,
		},
		{
			MethodName: "SafeTransferERC721WithData",
			Handler:    _ERC721_SafeTransferERC721WithData_Handler,
		},
		{
			MethodName: "ApproveERC721",
			Handler:    _ERC721_ApproveERC721_Handler,
		},
		{
			MethodName: "SetApprovalForAllERC721",
			Handler:    _ERC721_SetApprovalForAllERC721_Handler,
		},
		{
			MethodName: "SafeMintERC721",
			Handler:    _ERC721_SafeMintERC721_Handler,
		},
		{
			MethodName: "BurnERC721",
			Handler:    _ERC721_BurnERC721_Handler,
		},
		{
			MethodName: "DeployERC721",
			Handler:    _ERC721_DeployERC721_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "erc721/v1/erc721.proto",
}
