// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v6.33.2
// source: erc721/v1/erc721.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationERC721ApproveERC721 = "/api.erc721.v1.ERC721/ApproveERC721"
const OperationERC721BurnERC721 = "/api.erc721.v1.ERC721/BurnERC721"
const OperationERC721DeployERC721 = "/api.erc721.v1.ERC721/DeployERC721"
const OperationERC721GetERC721Approved = "/api.erc721.v1.ERC721/GetERC721Approved"
const OperationERC721GetERC721Balance = "/api.erc721.v1.ERC721/GetERC721Balance"
const OperationERC721GetERC721OwnerOf = "/api.erc721.v1.ERC721/GetERC721OwnerOf"
const OperationERC721GetERC721TokenInfo = "/api.erc721.v1.ERC721/GetERC721TokenInfo"
const OperationERC721GetERC721TokenURI = "/api.erc721.v1.ERC721/GetERC721TokenURI"
const OperationERC721IsApprovedForAllERC721 = "/api.erc721.v1.ERC721/IsApprovedForAllERC721"
const OperationERC721SafeMintERC721 = "/api.erc721.v1.ERC721/SafeMintERC721"
const OperationERC721SafeTransferERC721 = "/api.erc721.v1.ERC721/SafeTransferERC721"
const OperationERC721SafeTransferERC721WithData = "/api.erc721.v1.ERC721/SafeTransferERC721WithData"
const OperationERC721SetApprovalForAllERC721 = "/api.erc721.v1.ERC721/SetApprovalForAllERC721"
const OperationERC721TransferERC721 = "/api.erc721.v1.ERC721/TransferERC721"

type ERC721HTTPServer interface {
	// ApproveERC721 ApproveERC721 approves another address to transfer the specified token
	ApproveERC721(context.Context, *ApproveERC721Request) (*ApproveERC721Response, error)
	// BurnERC721 BurnERC721 burns an ERC721 token
	BurnERC721(context.Context, *BurnERC721Request) (*BurnERC721Response, error)
	// DeployERC721 DeployERC721 deploys a new ERC721 token contract
	DeployERC721(context.Context, *DeployERC721Request) (*DeployERC721Response, error)
	// GetERC721Approved GetERC721Approved returns the approved address for a token
	GetERC721Approved(context.Context, *GetERC721ApprovedRequest) (*GetERC721ApprovedResponse, error)
	// GetERC721Balance GetERC721Balance returns the ERC721 token balance (number of NFTs) of the specified address
	GetERC721Balance(context.Context, *GetERC721BalanceRequest) (*GetERC721BalanceResponse, error)
	// GetERC721OwnerOf GetERC721OwnerOf returns the owner of a specific token
	GetERC721OwnerOf(context.Context, *GetERC721OwnerOfRequest) (*GetERC721OwnerOfResponse, error)
	// GetERC721TokenInfo GetERC721TokenInfo returns ERC721 token information (name, symbol)
	GetERC721TokenInfo(context.Context, *GetERC721TokenInfoRequest) (*GetERC721TokenInfoResponse, error)
	// GetERC721TokenURI GetERC721TokenURI returns the URI for a specific token
	GetERC721TokenURI(context.Context, *GetERC721TokenURIRequest) (*GetERC721TokenURIResponse, error)
	// IsApprovedForAllERC721 IsApprovedForAllERC721 checks if an operator is approved for all tokens of an owner
	IsApprovedForAllERC721(context.Context, *IsApprovedForAllERC721Request) (*IsApprovedForAllERC721Response, error)
	// SafeMintERC721 SafeMintERC721 safely mints a new ERC721 token
	SafeMintERC721(context.Context, *SafeMintERC721Request) (*SafeMintERC721Response, error)
	// SafeTransferERC721 SafeTransferERC721 safely transfers an ERC721 token (calls onERC721Received on recipient)
	SafeTransferERC721(context.Context, *SafeTransferERC721Request) (*SafeTransferERC721Response, error)
	// SafeTransferERC721WithData SafeTransferERC721WithData safely transfers an ERC721 token with additional data
	SafeTransferERC721WithData(context.Context, *SafeTransferERC721WithDataRequest) (*SafeTransferERC721WithDataResponse, error)
	// SetApprovalForAllERC721 SetApprovalForAllERC721 enables or disables approval for a third party ("operator") to manage all tokens
	SetApprovalForAllERC721(context.Context, *SetApprovalForAllERC721Request) (*SetApprovalForAllERC721Response, error)
	// TransferERC721 TransferERC721 transfers an ERC721 token from the caller to the specified address
	TransferERC721(context.Context, *TransferERC721Request) (*TransferERC721Response, error)
}

func RegisterERC721HTTPServer(s *http.Server, srv ERC721HTTPServer) {
	r := s.Route("/")
	r.GET("/api/v1/erc721/balance", _ERC721_GetERC721Balance0_HTTP_Handler(srv))
	r.GET("/api/v1/erc721/info", _ERC721_GetERC721TokenInfo0_HTTP_Handler(srv))
	r.GET("/api/v1/erc721/token-uri", _ERC721_GetERC721TokenURI0_HTTP_Handler(srv))
	r.GET("/api/v1/erc721/owner-of", _ERC721_GetERC721OwnerOf0_HTTP_Handler(srv))
	r.GET("/api/v1/erc721/approved", _ERC721_GetERC721Approved0_HTTP_Handler(srv))
	r.GET("/api/v1/erc721/is-approved-for-all", _ERC721_IsApprovedForAllERC7210_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/transfer", _ERC721_TransferERC7210_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/safe-transfer", _ERC721_SafeTransferERC7210_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/safe-transfer-with-data", _ERC721_SafeTransferERC721WithData0_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/approve", _ERC721_ApproveERC7210_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/set-approval-for-all", _ERC721_SetApprovalForAllERC7210_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/safe-mint", _ERC721_SafeMintERC7210_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/burn", _ERC721_BurnERC7210_HTTP_Handler(srv))
	r.POST("/api/v1/erc721/deploy", _ERC721_DeployERC7210_HTTP_Handler(srv))
}

func _ERC721_GetERC721Balance0_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC721BalanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721GetERC721Balance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC721Balance(ctx, req.(*GetERC721BalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC721BalanceResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC721_GetERC721TokenInfo0_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC721TokenInfoRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721GetERC721TokenInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC721TokenInfo(ctx, req.(*GetERC721TokenInfoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC721TokenInfoResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC721_GetERC721TokenURI0_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC721TokenURIRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721GetERC721TokenURI)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC721TokenURI(ctx, req.(*GetERC721TokenURIRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC721TokenURIResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC721_GetERC721OwnerOf0_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC721OwnerOfRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721GetERC721OwnerOf)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC721OwnerOf(ctx, req.(*GetERC721OwnerOfRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC721OwnerOfResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC721_GetERC721Approved0_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC721ApprovedRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721GetERC721Approved)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC721Approved(ctx, req.(*GetERC721ApprovedRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC721ApprovedResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC721_IsApprovedForAllERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in IsApprovedForAllERC721Request
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721IsApprovedForAllERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.IsApprovedForAllERC721(ctx, req.(*IsApprovedForAllERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*IsApprovedForAllERC721Response)
		return ctx.Result(200, reply)
	}
}

func _ERC721_TransferERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TransferERC721Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721TransferERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TransferERC721(ctx, req.(*TransferERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TransferERC721Response)
		return ctx.Result(200, reply)
	}
}

func _ERC721_SafeTransferERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SafeTransferERC721Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721SafeTransferERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SafeTransferERC721(ctx, req.(*SafeTransferERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SafeTransferERC721Response)
		return ctx.Result(200, reply)
	}
}

func _ERC721_SafeTransferERC721WithData0_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SafeTransferERC721WithDataRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721SafeTransferERC721WithData)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SafeTransferERC721WithData(ctx, req.(*SafeTransferERC721WithDataRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SafeTransferERC721WithDataResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC721_ApproveERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ApproveERC721Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721ApproveERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ApproveERC721(ctx, req.(*ApproveERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ApproveERC721Response)
		return ctx.Result(200, reply)
	}
}

func _ERC721_SetApprovalForAllERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SetApprovalForAllERC721Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721SetApprovalForAllERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SetApprovalForAllERC721(ctx, req.(*SetApprovalForAllERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SetApprovalForAllERC721Response)
		return ctx.Result(200, reply)
	}
}

func _ERC721_SafeMintERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SafeMintERC721Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721SafeMintERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SafeMintERC721(ctx, req.(*SafeMintERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SafeMintERC721Response)
		return ctx.Result(200, reply)
	}
}

func _ERC721_BurnERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BurnERC721Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721BurnERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BurnERC721(ctx, req.(*BurnERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BurnERC721Response)
		return ctx.Result(200, reply)
	}
}

func _ERC721_DeployERC7210_HTTP_Handler(srv ERC721HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeployERC721Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC721DeployERC721)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeployERC721(ctx, req.(*DeployERC721Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeployERC721Response)
		return ctx.Result(200, reply)
	}
}

type ERC721HTTPClient interface {
	// ApproveERC721 ApproveERC721 approves another address to transfer the specified token
	ApproveERC721(ctx context.Context, req *ApproveERC721Request, opts ...http.CallOption) (rsp *ApproveERC721Response, err error)
	// BurnERC721 BurnERC721 burns an ERC721 token
	BurnERC721(ctx context.Context, req *BurnERC721Request, opts ...http.CallOption) (rsp *BurnERC721Response, err error)
	// DeployERC721 DeployERC721 deploys a new ERC721 token contract
	DeployERC721(ctx context.Context, req *DeployERC721Request, opts ...http.CallOption) (rsp *DeployERC721Response, err error)
	// GetERC721Approved GetERC721Approved returns the approved address for a token
	GetERC721Approved(ctx context.Context, req *GetERC721ApprovedRequest, opts ...http.CallOption) (rsp *GetERC721ApprovedResponse, err error)
	// GetERC721Balance GetERC721Balance returns the ERC721 token balance (number of NFTs) of the specified address
	GetERC721Balance(ctx context.Context, req *GetERC721BalanceRequest, opts ...http.CallOption) (rsp *GetERC721BalanceResponse, err error)
	// GetERC721OwnerOf GetERC721OwnerOf returns the owner of a specific token
	GetERC721OwnerOf(ctx context.Context, req *GetERC721OwnerOfRequest, opts ...http.CallOption) (rsp *GetERC721OwnerOfResponse, err error)
	// GetERC721TokenInfo GetERC721TokenInfo returns ERC721 token information (name, symbol)
	GetERC721TokenInfo(ctx context.Context, req *GetERC721TokenInfoRequest, opts ...http.CallOption) (rsp *GetERC721TokenInfoResponse, err error)
	// GetERC721TokenURI GetERC721TokenURI returns the URI for a specific token
	GetERC721TokenURI(ctx context.Context, req *GetERC721TokenURIRequest, opts ...http.CallOption) (rsp *GetERC721TokenURIResponse, err error)
	// IsApprovedForAllERC721 IsApprovedForAllERC721 checks if an operator is approved for all tokens of an owner
	IsApprovedForAllERC721(ctx context.Context, req *IsApprovedForAllERC721Request, opts ...http.CallOption) (rsp *IsApprovedForAllERC721Response, err error)
	// SafeMintERC721 SafeMintERC721 safely mints a new ERC721 token
	SafeMintERC721(ctx context.Context, req *SafeMintERC721Request, opts ...http.CallOption) (rsp *SafeMintERC721Response, err error)
	// SafeTransferERC721 SafeTransferERC721 safely transfers an ERC721 token (calls onERC721Received on recipient)
	SafeTransferERC721(ctx context.Context, req *SafeTransferERC721Request, opts ...http.CallOption) (rsp *SafeTransferERC721Response, err error)
	// SafeTransferERC721WithData SafeTransferERC721WithData safely transfers an ERC721 token with additional data
	SafeTransferERC721WithData(ctx context.Context, req *SafeTransferERC721WithDataRequest, opts ...http.CallOption) (rsp *SafeTransferERC721WithDataResponse, err error)
	// SetApprovalForAllERC721 SetApprovalForAllERC721 enables or disables approval for a third party ("operator") to manage all tokens
	SetApprovalForAllERC721(ctx context.Context, req *SetApprovalForAllERC721Request, opts ...http.CallOption) (rsp *SetApprovalForAllERC721Response, err error)
	// TransferERC721 TransferERC721 transfers an ERC721 token from the caller to the specified address
	TransferERC721(ctx context.Context, req *TransferERC721Request, opts ...http.CallOption) (rsp *TransferERC721Response, err error)
}

type ERC721HTTPClientImpl struct {
	cc *http.Client
}

func NewERC721HTTPClient(client *http.Client) ERC721HTTPClient {
	return &ERC721HTTPClientImpl{client}
}

// ApproveERC721 ApproveERC721 approves another address to transfer the specified token
func (c *ERC721HTTPClientImpl) ApproveERC721(ctx context.Context, in *ApproveERC721Request, opts ...http.CallOption) (*ApproveERC721Response, error) {
	var out ApproveERC721Response
	pattern := "/api/v1/erc721/approve"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721ApproveERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// BurnERC721 BurnERC721 burns an ERC721 token
func (c *ERC721HTTPClientImpl) BurnERC721(ctx context.Context, in *BurnERC721Request, opts ...http.CallOption) (*BurnERC721Response, error) {
	var out BurnERC721Response
	pattern := "/api/v1/erc721/burn"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721BurnERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeployERC721 DeployERC721 deploys a new ERC721 token contract
func (c *ERC721HTTPClientImpl) DeployERC721(ctx context.Context, in *DeployERC721Request, opts ...http.CallOption) (*DeployERC721Response, error) {
	var out DeployERC721Response
	pattern := "/api/v1/erc721/deploy"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721DeployERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC721Approved GetERC721Approved returns the approved address for a token
func (c *ERC721HTTPClientImpl) GetERC721Approved(ctx context.Context, in *GetERC721ApprovedRequest, opts ...http.CallOption) (*GetERC721ApprovedResponse, error) {
	var out GetERC721ApprovedResponse
	pattern := "/api/v1/erc721/approved"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC721GetERC721Approved))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC721Balance GetERC721Balance returns the ERC721 token balance (number of NFTs) of the specified address
func (c *ERC721HTTPClientImpl) GetERC721Balance(ctx context.Context, in *GetERC721BalanceRequest, opts ...http.CallOption) (*GetERC721BalanceResponse, error) {
	var out GetERC721BalanceResponse
	pattern := "/api/v1/erc721/balance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC721GetERC721Balance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC721OwnerOf GetERC721OwnerOf returns the owner of a specific token
func (c *ERC721HTTPClientImpl) GetERC721OwnerOf(ctx context.Context, in *GetERC721OwnerOfRequest, opts ...http.CallOption) (*GetERC721OwnerOfResponse, error) {
	var out GetERC721OwnerOfResponse
	pattern := "/api/v1/erc721/owner-of"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC721GetERC721OwnerOf))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC721TokenInfo GetERC721TokenInfo returns ERC721 token information (name, symbol)
func (c *ERC721HTTPClientImpl) GetERC721TokenInfo(ctx context.Context, in *GetERC721TokenInfoRequest, opts ...http.CallOption) (*GetERC721TokenInfoResponse, error) {
	var out GetERC721TokenInfoResponse
	pattern := "/api/v1/erc721/info"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC721GetERC721TokenInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC721TokenURI GetERC721TokenURI returns the URI for a specific token
func (c *ERC721HTTPClientImpl) GetERC721TokenURI(ctx context.Context, in *GetERC721TokenURIRequest, opts ...http.CallOption) (*GetERC721TokenURIResponse, error) {
	var out GetERC721TokenURIResponse
	pattern := "/api/v1/erc721/token-uri"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC721GetERC721TokenURI))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// IsApprovedForAllERC721 IsApprovedForAllERC721 checks if an operator is approved for all tokens of an owner
func (c *ERC721HTTPClientImpl) IsApprovedForAllERC721(ctx context.Context, in *IsApprovedForAllERC721Request, opts ...http.CallOption) (*IsApprovedForAllERC721Response, error) {
	var out IsApprovedForAllERC721Response
	pattern := "/api/v1/erc721/is-approved-for-all"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC721IsApprovedForAllERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SafeMintERC721 SafeMintERC721 safely mints a new ERC721 token
func (c *ERC721HTTPClientImpl) SafeMintERC721(ctx context.Context, in *SafeMintERC721Request, opts ...http.CallOption) (*SafeMintERC721Response, error) {
	var out SafeMintERC721Response
	pattern := "/api/v1/erc721/safe-mint"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721SafeMintERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SafeTransferERC721 SafeTransferERC721 safely transfers an ERC721 token (calls onERC721Received on recipient)
func (c *ERC721HTTPClientImpl) SafeTransferERC721(ctx context.Context, in *SafeTransferERC721Request, opts ...http.CallOption) (*SafeTransferERC721Response, error) {
	var out SafeTransferERC721Response
	pattern := "/api/v1/erc721/safe-transfer"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721SafeTransferERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SafeTransferERC721WithData SafeTransferERC721WithData safely transfers an ERC721 token with additional data
func (c *ERC721HTTPClientImpl) SafeTransferERC721WithData(ctx context.Context, in *SafeTransferERC721WithDataRequest, opts ...http.CallOption) (*SafeTransferERC721WithDataResponse, error) {
	var out SafeTransferERC721WithDataResponse
	pattern := "/api/v1/erc721/safe-transfer-with-data"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721SafeTransferERC721WithData))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SetApprovalForAllERC721 SetApprovalForAllERC721 enables or disables approval for a third party ("operator") to manage all tokens
func (c *ERC721HTTPClientImpl) SetApprovalForAllERC721(ctx context.Context, in *SetApprovalForAllERC721Request, opts ...http.CallOption) (*SetApprovalForAllERC721Response, error) {
	var out SetApprovalForAllERC721Response
	pattern := "/api/v1/erc721/set-approval-for-all"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721SetApprovalForAllERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// TransferERC721 TransferERC721 transfers an ERC721 token from the caller to the specified address
func (c *ERC721HTTPClientImpl) TransferERC721(ctx context.Context, in *TransferERC721Request, opts ...http.CallOption) (*TransferERC721Response, error) {
	var out TransferERC721Response
	pattern := "/api/v1/erc721/transfer"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC721TransferERC721))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
