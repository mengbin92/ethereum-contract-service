// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v6.33.2
// source: erc20/v1/erc20.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationERC20ApproveERC20 = "/api.erc20.v1.ERC20/ApproveERC20"
const OperationERC20BurnERC20 = "/api.erc20.v1.ERC20/BurnERC20"
const OperationERC20BurnFromERC20 = "/api.erc20.v1.ERC20/BurnFromERC20"
const OperationERC20DeployERC20 = "/api.erc20.v1.ERC20/DeployERC20"
const OperationERC20GetERC20Allowance = "/api.erc20.v1.ERC20/GetERC20Allowance"
const OperationERC20GetERC20Balance = "/api.erc20.v1.ERC20/GetERC20Balance"
const OperationERC20GetERC20Info = "/api.erc20.v1.ERC20/GetERC20Info"
const OperationERC20MintERC20 = "/api.erc20.v1.ERC20/MintERC20"
const OperationERC20TransferERC20 = "/api.erc20.v1.ERC20/TransferERC20"
const OperationERC20TransferFromERC20 = "/api.erc20.v1.ERC20/TransferFromERC20"

type ERC20HTTPServer interface {
	// ApproveERC20 ApproveERC20 approves the spender to spend ERC20 tokens
	ApproveERC20(context.Context, *ApproveERC20Request) (*ApproveERC20Response, error)
	// BurnERC20 BurnERC20 burns ERC20 tokens from the caller's balance
	BurnERC20(context.Context, *BurnERC20Request) (*BurnERC20Response, error)
	// BurnFromERC20 BurnFromERC20 burns ERC20 tokens from a specified address (requires approval)
	BurnFromERC20(context.Context, *BurnFromERC20Request) (*BurnFromERC20Response, error)
	// DeployERC20 DeployERC20 deploys a new ERC20 token contract
	DeployERC20(context.Context, *DeployERC20Request) (*DeployERC20Response, error)
	// GetERC20Allowance GetERC20Allowance returns the amount of tokens that the spender is allowed to spend
	GetERC20Allowance(context.Context, *GetERC20AllowanceRequest) (*GetERC20AllowanceResponse, error)
	// GetERC20Balance GetERC20Balance returns the ERC20 token balance of the specified address
	GetERC20Balance(context.Context, *GetERC20BalanceRequest) (*GetERC20BalanceResponse, error)
	// GetERC20Info GetERC20Info returns ERC20 token information (name, symbol, decimals, total supply)
	GetERC20Info(context.Context, *GetERC20InfoRequest) (*GetERC20InfoResponse, error)
	// MintERC20 MintERC20 mints new ERC20 tokens (only for contracts with mint function)
	MintERC20(context.Context, *MintERC20Request) (*MintERC20Response, error)
	// TransferERC20 TransferERC20 transfers ERC20 tokens from the caller to the specified address
	TransferERC20(context.Context, *TransferERC20Request) (*TransferERC20Response, error)
	// TransferFromERC20 TransferFromERC20 transfers ERC20 tokens from one address to another (requires approval)
	TransferFromERC20(context.Context, *TransferFromERC20Request) (*TransferFromERC20Response, error)
}

func RegisterERC20HTTPServer(s *http.Server, srv ERC20HTTPServer) {
	r := s.Route("/")
	r.GET("/api/v1/erc20/balance", _ERC20_GetERC20Balance0_HTTP_Handler(srv))
	r.GET("/api/v1/erc20/info", _ERC20_GetERC20Info0_HTTP_Handler(srv))
	r.POST("/api/v1/erc20/transfer", _ERC20_TransferERC200_HTTP_Handler(srv))
	r.POST("/api/v1/erc20/approve", _ERC20_ApproveERC200_HTTP_Handler(srv))
	r.GET("/api/v1/erc20/allowance", _ERC20_GetERC20Allowance0_HTTP_Handler(srv))
	r.POST("/api/v1/erc20/transfer-from", _ERC20_TransferFromERC200_HTTP_Handler(srv))
	r.POST("/api/v1/erc20/mint", _ERC20_MintERC200_HTTP_Handler(srv))
	r.POST("/api/v1/erc20/burn", _ERC20_BurnERC200_HTTP_Handler(srv))
	r.POST("/api/v1/erc20/burn-from", _ERC20_BurnFromERC200_HTTP_Handler(srv))
	r.POST("/api/v1/erc20/deploy", _ERC20_DeployERC200_HTTP_Handler(srv))
}

func _ERC20_GetERC20Balance0_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC20BalanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20GetERC20Balance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC20Balance(ctx, req.(*GetERC20BalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC20BalanceResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC20_GetERC20Info0_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC20InfoRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20GetERC20Info)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC20Info(ctx, req.(*GetERC20InfoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC20InfoResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC20_TransferERC200_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TransferERC20Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20TransferERC20)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TransferERC20(ctx, req.(*TransferERC20Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TransferERC20Response)
		return ctx.Result(200, reply)
	}
}

func _ERC20_ApproveERC200_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ApproveERC20Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20ApproveERC20)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ApproveERC20(ctx, req.(*ApproveERC20Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ApproveERC20Response)
		return ctx.Result(200, reply)
	}
}

func _ERC20_GetERC20Allowance0_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC20AllowanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20GetERC20Allowance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC20Allowance(ctx, req.(*GetERC20AllowanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC20AllowanceResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC20_TransferFromERC200_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TransferFromERC20Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20TransferFromERC20)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TransferFromERC20(ctx, req.(*TransferFromERC20Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TransferFromERC20Response)
		return ctx.Result(200, reply)
	}
}

func _ERC20_MintERC200_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MintERC20Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20MintERC20)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MintERC20(ctx, req.(*MintERC20Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MintERC20Response)
		return ctx.Result(200, reply)
	}
}

func _ERC20_BurnERC200_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BurnERC20Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20BurnERC20)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BurnERC20(ctx, req.(*BurnERC20Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BurnERC20Response)
		return ctx.Result(200, reply)
	}
}

func _ERC20_BurnFromERC200_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BurnFromERC20Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20BurnFromERC20)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BurnFromERC20(ctx, req.(*BurnFromERC20Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BurnFromERC20Response)
		return ctx.Result(200, reply)
	}
}

func _ERC20_DeployERC200_HTTP_Handler(srv ERC20HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeployERC20Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC20DeployERC20)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeployERC20(ctx, req.(*DeployERC20Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeployERC20Response)
		return ctx.Result(200, reply)
	}
}

type ERC20HTTPClient interface {
	// ApproveERC20 ApproveERC20 approves the spender to spend ERC20 tokens
	ApproveERC20(ctx context.Context, req *ApproveERC20Request, opts ...http.CallOption) (rsp *ApproveERC20Response, err error)
	// BurnERC20 BurnERC20 burns ERC20 tokens from the caller's balance
	BurnERC20(ctx context.Context, req *BurnERC20Request, opts ...http.CallOption) (rsp *BurnERC20Response, err error)
	// BurnFromERC20 BurnFromERC20 burns ERC20 tokens from a specified address (requires approval)
	BurnFromERC20(ctx context.Context, req *BurnFromERC20Request, opts ...http.CallOption) (rsp *BurnFromERC20Response, err error)
	// DeployERC20 DeployERC20 deploys a new ERC20 token contract
	DeployERC20(ctx context.Context, req *DeployERC20Request, opts ...http.CallOption) (rsp *DeployERC20Response, err error)
	// GetERC20Allowance GetERC20Allowance returns the amount of tokens that the spender is allowed to spend
	GetERC20Allowance(ctx context.Context, req *GetERC20AllowanceRequest, opts ...http.CallOption) (rsp *GetERC20AllowanceResponse, err error)
	// GetERC20Balance GetERC20Balance returns the ERC20 token balance of the specified address
	GetERC20Balance(ctx context.Context, req *GetERC20BalanceRequest, opts ...http.CallOption) (rsp *GetERC20BalanceResponse, err error)
	// GetERC20Info GetERC20Info returns ERC20 token information (name, symbol, decimals, total supply)
	GetERC20Info(ctx context.Context, req *GetERC20InfoRequest, opts ...http.CallOption) (rsp *GetERC20InfoResponse, err error)
	// MintERC20 MintERC20 mints new ERC20 tokens (only for contracts with mint function)
	MintERC20(ctx context.Context, req *MintERC20Request, opts ...http.CallOption) (rsp *MintERC20Response, err error)
	// TransferERC20 TransferERC20 transfers ERC20 tokens from the caller to the specified address
	TransferERC20(ctx context.Context, req *TransferERC20Request, opts ...http.CallOption) (rsp *TransferERC20Response, err error)
	// TransferFromERC20 TransferFromERC20 transfers ERC20 tokens from one address to another (requires approval)
	TransferFromERC20(ctx context.Context, req *TransferFromERC20Request, opts ...http.CallOption) (rsp *TransferFromERC20Response, err error)
}

type ERC20HTTPClientImpl struct {
	cc *http.Client
}

func NewERC20HTTPClient(client *http.Client) ERC20HTTPClient {
	return &ERC20HTTPClientImpl{client}
}

// ApproveERC20 ApproveERC20 approves the spender to spend ERC20 tokens
func (c *ERC20HTTPClientImpl) ApproveERC20(ctx context.Context, in *ApproveERC20Request, opts ...http.CallOption) (*ApproveERC20Response, error) {
	var out ApproveERC20Response
	pattern := "/api/v1/erc20/approve"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC20ApproveERC20))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// BurnERC20 BurnERC20 burns ERC20 tokens from the caller's balance
func (c *ERC20HTTPClientImpl) BurnERC20(ctx context.Context, in *BurnERC20Request, opts ...http.CallOption) (*BurnERC20Response, error) {
	var out BurnERC20Response
	pattern := "/api/v1/erc20/burn"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC20BurnERC20))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// BurnFromERC20 BurnFromERC20 burns ERC20 tokens from a specified address (requires approval)
func (c *ERC20HTTPClientImpl) BurnFromERC20(ctx context.Context, in *BurnFromERC20Request, opts ...http.CallOption) (*BurnFromERC20Response, error) {
	var out BurnFromERC20Response
	pattern := "/api/v1/erc20/burn-from"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC20BurnFromERC20))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeployERC20 DeployERC20 deploys a new ERC20 token contract
func (c *ERC20HTTPClientImpl) DeployERC20(ctx context.Context, in *DeployERC20Request, opts ...http.CallOption) (*DeployERC20Response, error) {
	var out DeployERC20Response
	pattern := "/api/v1/erc20/deploy"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC20DeployERC20))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC20Allowance GetERC20Allowance returns the amount of tokens that the spender is allowed to spend
func (c *ERC20HTTPClientImpl) GetERC20Allowance(ctx context.Context, in *GetERC20AllowanceRequest, opts ...http.CallOption) (*GetERC20AllowanceResponse, error) {
	var out GetERC20AllowanceResponse
	pattern := "/api/v1/erc20/allowance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC20GetERC20Allowance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC20Balance GetERC20Balance returns the ERC20 token balance of the specified address
func (c *ERC20HTTPClientImpl) GetERC20Balance(ctx context.Context, in *GetERC20BalanceRequest, opts ...http.CallOption) (*GetERC20BalanceResponse, error) {
	var out GetERC20BalanceResponse
	pattern := "/api/v1/erc20/balance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC20GetERC20Balance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC20Info GetERC20Info returns ERC20 token information (name, symbol, decimals, total supply)
func (c *ERC20HTTPClientImpl) GetERC20Info(ctx context.Context, in *GetERC20InfoRequest, opts ...http.CallOption) (*GetERC20InfoResponse, error) {
	var out GetERC20InfoResponse
	pattern := "/api/v1/erc20/info"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC20GetERC20Info))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// MintERC20 MintERC20 mints new ERC20 tokens (only for contracts with mint function)
func (c *ERC20HTTPClientImpl) MintERC20(ctx context.Context, in *MintERC20Request, opts ...http.CallOption) (*MintERC20Response, error) {
	var out MintERC20Response
	pattern := "/api/v1/erc20/mint"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC20MintERC20))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// TransferERC20 TransferERC20 transfers ERC20 tokens from the caller to the specified address
func (c *ERC20HTTPClientImpl) TransferERC20(ctx context.Context, in *TransferERC20Request, opts ...http.CallOption) (*TransferERC20Response, error) {
	var out TransferERC20Response
	pattern := "/api/v1/erc20/transfer"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC20TransferERC20))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// TransferFromERC20 TransferFromERC20 transfers ERC20 tokens from one address to another (requires approval)
func (c *ERC20HTTPClientImpl) TransferFromERC20(ctx context.Context, in *TransferFromERC20Request, opts ...http.CallOption) (*TransferFromERC20Response, error) {
	var out TransferFromERC20Response
	pattern := "/api/v1/erc20/transfer-from"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC20TransferFromERC20))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
