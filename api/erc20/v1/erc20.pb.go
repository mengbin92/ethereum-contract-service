// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.2
// source: erc20/v1/erc20.proto

package v1

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetERC20BalanceRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	OwnerAddress    string                 `protobuf:"bytes,2,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address,omitempty"`          // Address to query balance for
	ContractType    string                 `protobuf:"bytes,3,opt,name=contract_type,json=contractType,proto3" json:"contract_type,omitempty"`          // Contract type: "standard" or "ownable" (default: "standard")
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetERC20BalanceRequest) Reset() {
	*x = GetERC20BalanceRequest{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetERC20BalanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetERC20BalanceRequest) ProtoMessage() {}

func (x *GetERC20BalanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetERC20BalanceRequest.ProtoReflect.Descriptor instead.
func (*GetERC20BalanceRequest) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{0}
}

func (x *GetERC20BalanceRequest) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *GetERC20BalanceRequest) GetOwnerAddress() string {
	if x != nil {
		return x.OwnerAddress
	}
	return ""
}

func (x *GetERC20BalanceRequest) GetContractType() string {
	if x != nil {
		return x.ContractType
	}
	return ""
}

type GetERC20BalanceResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Balance         string                 `protobuf:"bytes,1,opt,name=balance,proto3" json:"balance,omitempty"`                                        // Token balance (as string to handle large numbers)
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	OwnerAddress    string                 `protobuf:"bytes,3,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address,omitempty"`          // Owner address
	Decimals        uint32                 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty"`                                     // Token decimals
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetERC20BalanceResponse) Reset() {
	*x = GetERC20BalanceResponse{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetERC20BalanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetERC20BalanceResponse) ProtoMessage() {}

func (x *GetERC20BalanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetERC20BalanceResponse.ProtoReflect.Descriptor instead.
func (*GetERC20BalanceResponse) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{1}
}

func (x *GetERC20BalanceResponse) GetBalance() string {
	if x != nil {
		return x.Balance
	}
	return ""
}

func (x *GetERC20BalanceResponse) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *GetERC20BalanceResponse) GetOwnerAddress() string {
	if x != nil {
		return x.OwnerAddress
	}
	return ""
}

func (x *GetERC20BalanceResponse) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

type GetERC20InfoRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	ContractType    string                 `protobuf:"bytes,2,opt,name=contract_type,json=contractType,proto3" json:"contract_type,omitempty"`          // Contract type: "standard" or "ownable" (default: "standard")
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetERC20InfoRequest) Reset() {
	*x = GetERC20InfoRequest{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetERC20InfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetERC20InfoRequest) ProtoMessage() {}

func (x *GetERC20InfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetERC20InfoRequest.ProtoReflect.Descriptor instead.
func (*GetERC20InfoRequest) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{2}
}

func (x *GetERC20InfoRequest) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *GetERC20InfoRequest) GetContractType() string {
	if x != nil {
		return x.ContractType
	}
	return ""
}

type GetERC20InfoResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Name            string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                              // Token name
	Symbol          string                 `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`                                          // Token symbol
	Decimals        uint32                 `protobuf:"varint,3,opt,name=decimals,proto3" json:"decimals,omitempty"`                                     // Token decimals
	TotalSupply     string                 `protobuf:"bytes,4,opt,name=total_supply,json=totalSupply,proto3" json:"total_supply,omitempty"`             // Total supply (as string to handle large numbers)
	ContractAddress string                 `protobuf:"bytes,5,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetERC20InfoResponse) Reset() {
	*x = GetERC20InfoResponse{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetERC20InfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetERC20InfoResponse) ProtoMessage() {}

func (x *GetERC20InfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetERC20InfoResponse.ProtoReflect.Descriptor instead.
func (*GetERC20InfoResponse) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{3}
}

func (x *GetERC20InfoResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetERC20InfoResponse) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *GetERC20InfoResponse) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *GetERC20InfoResponse) GetTotalSupply() string {
	if x != nil {
		return x.TotalSupply
	}
	return ""
}

func (x *GetERC20InfoResponse) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

type TransferERC20Request struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	ToAddress       string                 `protobuf:"bytes,2,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`                   // Recipient address
	Amount          string                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount to transfer (as string to handle large numbers)
	PrivateKey      string                 `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`                // Private key (hex encoded, 64 characters, with or without 0x prefix)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TransferERC20Request) Reset() {
	*x = TransferERC20Request{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferERC20Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferERC20Request) ProtoMessage() {}

func (x *TransferERC20Request) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferERC20Request.ProtoReflect.Descriptor instead.
func (*TransferERC20Request) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{4}
}

func (x *TransferERC20Request) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *TransferERC20Request) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *TransferERC20Request) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *TransferERC20Request) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

type TransferERC20Response struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TxHash          string                 `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`                            // Transaction hash
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	FromAddress     string                 `protobuf:"bytes,3,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`             // Sender address
	ToAddress       string                 `protobuf:"bytes,4,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`                   // Recipient address
	Amount          string                 `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount transferred
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TransferERC20Response) Reset() {
	*x = TransferERC20Response{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferERC20Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferERC20Response) ProtoMessage() {}

func (x *TransferERC20Response) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferERC20Response.ProtoReflect.Descriptor instead.
func (*TransferERC20Response) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{5}
}

func (x *TransferERC20Response) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *TransferERC20Response) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *TransferERC20Response) GetFromAddress() string {
	if x != nil {
		return x.FromAddress
	}
	return ""
}

func (x *TransferERC20Response) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *TransferERC20Response) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type ApproveERC20Request struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	SpenderAddress  string                 `protobuf:"bytes,2,opt,name=spender_address,json=spenderAddress,proto3" json:"spender_address,omitempty"`    // Spender address
	Amount          string                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount to approve (as string to handle large numbers)
	PrivateKey      string                 `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`                // Private key (hex encoded, 64 characters, with or without 0x prefix)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ApproveERC20Request) Reset() {
	*x = ApproveERC20Request{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveERC20Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveERC20Request) ProtoMessage() {}

func (x *ApproveERC20Request) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveERC20Request.ProtoReflect.Descriptor instead.
func (*ApproveERC20Request) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{6}
}

func (x *ApproveERC20Request) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *ApproveERC20Request) GetSpenderAddress() string {
	if x != nil {
		return x.SpenderAddress
	}
	return ""
}

func (x *ApproveERC20Request) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *ApproveERC20Request) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

type ApproveERC20Response struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TxHash          string                 `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`                            // Transaction hash
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	OwnerAddress    string                 `protobuf:"bytes,3,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address,omitempty"`          // Owner address
	SpenderAddress  string                 `protobuf:"bytes,4,opt,name=spender_address,json=spenderAddress,proto3" json:"spender_address,omitempty"`    // Spender address
	Amount          string                 `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Approved amount
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ApproveERC20Response) Reset() {
	*x = ApproveERC20Response{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveERC20Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveERC20Response) ProtoMessage() {}

func (x *ApproveERC20Response) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveERC20Response.ProtoReflect.Descriptor instead.
func (*ApproveERC20Response) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{7}
}

func (x *ApproveERC20Response) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *ApproveERC20Response) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *ApproveERC20Response) GetOwnerAddress() string {
	if x != nil {
		return x.OwnerAddress
	}
	return ""
}

func (x *ApproveERC20Response) GetSpenderAddress() string {
	if x != nil {
		return x.SpenderAddress
	}
	return ""
}

func (x *ApproveERC20Response) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type GetERC20AllowanceRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	OwnerAddress    string                 `protobuf:"bytes,2,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address,omitempty"`          // Owner address
	SpenderAddress  string                 `protobuf:"bytes,3,opt,name=spender_address,json=spenderAddress,proto3" json:"spender_address,omitempty"`    // Spender address
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetERC20AllowanceRequest) Reset() {
	*x = GetERC20AllowanceRequest{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetERC20AllowanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetERC20AllowanceRequest) ProtoMessage() {}

func (x *GetERC20AllowanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetERC20AllowanceRequest.ProtoReflect.Descriptor instead.
func (*GetERC20AllowanceRequest) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{8}
}

func (x *GetERC20AllowanceRequest) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *GetERC20AllowanceRequest) GetOwnerAddress() string {
	if x != nil {
		return x.OwnerAddress
	}
	return ""
}

func (x *GetERC20AllowanceRequest) GetSpenderAddress() string {
	if x != nil {
		return x.SpenderAddress
	}
	return ""
}

type GetERC20AllowanceResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Allowance       string                 `protobuf:"bytes,1,opt,name=allowance,proto3" json:"allowance,omitempty"`                                    // Allowed amount (as string to handle large numbers)
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	OwnerAddress    string                 `protobuf:"bytes,3,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address,omitempty"`          // Owner address
	SpenderAddress  string                 `protobuf:"bytes,4,opt,name=spender_address,json=spenderAddress,proto3" json:"spender_address,omitempty"`    // Spender address
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetERC20AllowanceResponse) Reset() {
	*x = GetERC20AllowanceResponse{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetERC20AllowanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetERC20AllowanceResponse) ProtoMessage() {}

func (x *GetERC20AllowanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetERC20AllowanceResponse.ProtoReflect.Descriptor instead.
func (*GetERC20AllowanceResponse) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{9}
}

func (x *GetERC20AllowanceResponse) GetAllowance() string {
	if x != nil {
		return x.Allowance
	}
	return ""
}

func (x *GetERC20AllowanceResponse) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *GetERC20AllowanceResponse) GetOwnerAddress() string {
	if x != nil {
		return x.OwnerAddress
	}
	return ""
}

func (x *GetERC20AllowanceResponse) GetSpenderAddress() string {
	if x != nil {
		return x.SpenderAddress
	}
	return ""
}

type TransferFromERC20Request struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	FromAddress     string                 `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`             // Address to transfer from
	ToAddress       string                 `protobuf:"bytes,3,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`                   // Recipient address
	Amount          string                 `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount to transfer (as string to handle large numbers)
	PrivateKey      string                 `protobuf:"bytes,5,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`                // Private key of the spender (hex encoded, 64 characters, with or without 0x prefix)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TransferFromERC20Request) Reset() {
	*x = TransferFromERC20Request{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferFromERC20Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferFromERC20Request) ProtoMessage() {}

func (x *TransferFromERC20Request) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferFromERC20Request.ProtoReflect.Descriptor instead.
func (*TransferFromERC20Request) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{10}
}

func (x *TransferFromERC20Request) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *TransferFromERC20Request) GetFromAddress() string {
	if x != nil {
		return x.FromAddress
	}
	return ""
}

func (x *TransferFromERC20Request) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *TransferFromERC20Request) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *TransferFromERC20Request) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

type TransferFromERC20Response struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TxHash          string                 `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`                            // Transaction hash
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	FromAddress     string                 `protobuf:"bytes,3,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`             // Address transferred from
	ToAddress       string                 `protobuf:"bytes,4,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`                   // Recipient address
	Amount          string                 `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount transferred
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TransferFromERC20Response) Reset() {
	*x = TransferFromERC20Response{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferFromERC20Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferFromERC20Response) ProtoMessage() {}

func (x *TransferFromERC20Response) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferFromERC20Response.ProtoReflect.Descriptor instead.
func (*TransferFromERC20Response) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{11}
}

func (x *TransferFromERC20Response) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *TransferFromERC20Response) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *TransferFromERC20Response) GetFromAddress() string {
	if x != nil {
		return x.FromAddress
	}
	return ""
}

func (x *TransferFromERC20Response) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *TransferFromERC20Response) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type MintERC20Request struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	ToAddress       string                 `protobuf:"bytes,2,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`                   // Address to mint tokens to
	Amount          string                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount to mint (as string to handle large numbers)
	PrivateKey      string                 `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`                // Private key (hex encoded, 64 characters, with or without 0x prefix)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *MintERC20Request) Reset() {
	*x = MintERC20Request{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MintERC20Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MintERC20Request) ProtoMessage() {}

func (x *MintERC20Request) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MintERC20Request.ProtoReflect.Descriptor instead.
func (*MintERC20Request) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{12}
}

func (x *MintERC20Request) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *MintERC20Request) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *MintERC20Request) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *MintERC20Request) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

type MintERC20Response struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TxHash          string                 `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`                            // Transaction hash
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	ToAddress       string                 `protobuf:"bytes,3,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`                   // Address that received minted tokens
	Amount          string                 `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount minted
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *MintERC20Response) Reset() {
	*x = MintERC20Response{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MintERC20Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MintERC20Response) ProtoMessage() {}

func (x *MintERC20Response) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MintERC20Response.ProtoReflect.Descriptor instead.
func (*MintERC20Response) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{13}
}

func (x *MintERC20Response) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *MintERC20Response) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *MintERC20Response) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *MintERC20Response) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type BurnERC20Request struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	Amount          string                 `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount to burn (as string to handle large numbers)
	PrivateKey      string                 `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`                // Private key (hex encoded, 64 characters, with or without 0x prefix)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BurnERC20Request) Reset() {
	*x = BurnERC20Request{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BurnERC20Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BurnERC20Request) ProtoMessage() {}

func (x *BurnERC20Request) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BurnERC20Request.ProtoReflect.Descriptor instead.
func (*BurnERC20Request) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{14}
}

func (x *BurnERC20Request) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *BurnERC20Request) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *BurnERC20Request) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

type BurnERC20Response struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TxHash          string                 `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`                            // Transaction hash
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	FromAddress     string                 `protobuf:"bytes,3,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`             // Address that burned tokens
	Amount          string                 `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount burned
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BurnERC20Response) Reset() {
	*x = BurnERC20Response{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BurnERC20Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BurnERC20Response) ProtoMessage() {}

func (x *BurnERC20Response) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BurnERC20Response.ProtoReflect.Descriptor instead.
func (*BurnERC20Response) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{15}
}

func (x *BurnERC20Response) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *BurnERC20Response) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *BurnERC20Response) GetFromAddress() string {
	if x != nil {
		return x.FromAddress
	}
	return ""
}

func (x *BurnERC20Response) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type BurnFromERC20Request struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ContractAddress string                 `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // ERC20 contract address
	FromAddress     string                 `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`             // Address to burn tokens from
	Amount          string                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount to burn (as string to handle large numbers)
	PrivateKey      string                 `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`                // Private key of the spender (hex encoded, 64 characters, with or without 0x prefix)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BurnFromERC20Request) Reset() {
	*x = BurnFromERC20Request{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BurnFromERC20Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BurnFromERC20Request) ProtoMessage() {}

func (x *BurnFromERC20Request) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BurnFromERC20Request.ProtoReflect.Descriptor instead.
func (*BurnFromERC20Request) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{16}
}

func (x *BurnFromERC20Request) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *BurnFromERC20Request) GetFromAddress() string {
	if x != nil {
		return x.FromAddress
	}
	return ""
}

func (x *BurnFromERC20Request) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *BurnFromERC20Request) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

type BurnFromERC20Response struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TxHash          string                 `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`                            // Transaction hash
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Contract address
	FromAddress     string                 `protobuf:"bytes,3,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`             // Address that tokens were burned from
	Amount          string                 `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`                                          // Amount burned
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BurnFromERC20Response) Reset() {
	*x = BurnFromERC20Response{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BurnFromERC20Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BurnFromERC20Response) ProtoMessage() {}

func (x *BurnFromERC20Response) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BurnFromERC20Response.ProtoReflect.Descriptor instead.
func (*BurnFromERC20Response) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{17}
}

func (x *BurnFromERC20Response) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *BurnFromERC20Response) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *BurnFromERC20Response) GetFromAddress() string {
	if x != nil {
		return x.FromAddress
	}
	return ""
}

func (x *BurnFromERC20Response) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type DeployERC20Request struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                        // Token name (e.g., "My Token")
	Symbol        string                 `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`                                    // Token symbol (e.g., "MTK")
	Decimals      uint32                 `protobuf:"varint,3,opt,name=decimals,proto3" json:"decimals,omitempty"`                               // Token decimals (usually 18)
	InitialSupply string                 `protobuf:"bytes,4,opt,name=initial_supply,json=initialSupply,proto3" json:"initial_supply,omitempty"` // Initial supply (as string to handle large numbers)
	PrivateKey    string                 `protobuf:"bytes,5,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`          // Private key for deployment (hex encoded, 64 characters, with or without 0x prefix)
	ContractType  string                 `protobuf:"bytes,6,opt,name=contract_type,json=contractType,proto3" json:"contract_type,omitempty"`    // Contract type: "standard" or "ownable" (default: "standard")
	UseAdmin      bool                   `protobuf:"varint,7,opt,name=use_admin,json=useAdmin,proto3" json:"use_admin,omitempty"`               // Use admin address as owner for ownable contract (default: false)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeployERC20Request) Reset() {
	*x = DeployERC20Request{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeployERC20Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeployERC20Request) ProtoMessage() {}

func (x *DeployERC20Request) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeployERC20Request.ProtoReflect.Descriptor instead.
func (*DeployERC20Request) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{18}
}

func (x *DeployERC20Request) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DeployERC20Request) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *DeployERC20Request) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *DeployERC20Request) GetInitialSupply() string {
	if x != nil {
		return x.InitialSupply
	}
	return ""
}

func (x *DeployERC20Request) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

func (x *DeployERC20Request) GetContractType() string {
	if x != nil {
		return x.ContractType
	}
	return ""
}

func (x *DeployERC20Request) GetUseAdmin() bool {
	if x != nil {
		return x.UseAdmin
	}
	return false
}

type DeployERC20Response struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TxHash          string                 `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`                            // Deployment transaction hash
	ContractAddress string                 `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"` // Deployed contract address
	DeployerAddress string                 `protobuf:"bytes,3,opt,name=deployer_address,json=deployerAddress,proto3" json:"deployer_address,omitempty"` // Address that deployed the contract
	Name            string                 `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`                                              // Token name
	Symbol          string                 `protobuf:"bytes,5,opt,name=symbol,proto3" json:"symbol,omitempty"`                                          // Token symbol
	Decimals        uint32                 `protobuf:"varint,6,opt,name=decimals,proto3" json:"decimals,omitempty"`                                     // Token decimals
	InitialSupply   string                 `protobuf:"bytes,7,opt,name=initial_supply,json=initialSupply,proto3" json:"initial_supply,omitempty"`       // Initial supply
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DeployERC20Response) Reset() {
	*x = DeployERC20Response{}
	mi := &file_erc20_v1_erc20_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeployERC20Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeployERC20Response) ProtoMessage() {}

func (x *DeployERC20Response) ProtoReflect() protoreflect.Message {
	mi := &file_erc20_v1_erc20_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeployERC20Response.ProtoReflect.Descriptor instead.
func (*DeployERC20Response) Descriptor() ([]byte, []int) {
	return file_erc20_v1_erc20_proto_rawDescGZIP(), []int{19}
}

func (x *DeployERC20Response) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *DeployERC20Response) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *DeployERC20Response) GetDeployerAddress() string {
	if x != nil {
		return x.DeployerAddress
	}
	return ""
}

func (x *DeployERC20Response) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DeployERC20Response) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *DeployERC20Response) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *DeployERC20Response) GetInitialSupply() string {
	if x != nil {
		return x.InitialSupply
	}
	return ""
}

var File_erc20_v1_erc20_proto protoreflect.FileDescriptor

const file_erc20_v1_erc20_proto_rawDesc = "" +
	"\n" +
	"\x14erc20/v1/erc20.proto\x12\fapi.erc20.v1\x1a\x1cgoogle/api/annotations.proto\"\x8d\x01\n" +
	"\x16GetERC20BalanceRequest\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12#\n" +
	"\rowner_address\x18\x02 \x01(\tR\fownerAddress\x12#\n" +
	"\rcontract_type\x18\x03 \x01(\tR\fcontractType\"\x9f\x01\n" +
	"\x17GetERC20BalanceResponse\x12\x18\n" +
	"\abalance\x18\x01 \x01(\tR\abalance\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12#\n" +
	"\rowner_address\x18\x03 \x01(\tR\fownerAddress\x12\x1a\n" +
	"\bdecimals\x18\x04 \x01(\rR\bdecimals\"e\n" +
	"\x13GetERC20InfoRequest\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12#\n" +
	"\rcontract_type\x18\x02 \x01(\tR\fcontractType\"\xac\x01\n" +
	"\x14GetERC20InfoResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06symbol\x18\x02 \x01(\tR\x06symbol\x12\x1a\n" +
	"\bdecimals\x18\x03 \x01(\rR\bdecimals\x12!\n" +
	"\ftotal_supply\x18\x04 \x01(\tR\vtotalSupply\x12)\n" +
	"\x10contract_address\x18\x05 \x01(\tR\x0fcontractAddress\"\x99\x01\n" +
	"\x14TransferERC20Request\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12\x1d\n" +
	"\n" +
	"to_address\x18\x02 \x01(\tR\ttoAddress\x12\x16\n" +
	"\x06amount\x18\x03 \x01(\tR\x06amount\x12\x1f\n" +
	"\vprivate_key\x18\x04 \x01(\tR\n" +
	"privateKey\"\xb5\x01\n" +
	"\x15TransferERC20Response\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12!\n" +
	"\ffrom_address\x18\x03 \x01(\tR\vfromAddress\x12\x1d\n" +
	"\n" +
	"to_address\x18\x04 \x01(\tR\ttoAddress\x12\x16\n" +
	"\x06amount\x18\x05 \x01(\tR\x06amount\"\xa2\x01\n" +
	"\x13ApproveERC20Request\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12'\n" +
	"\x0fspender_address\x18\x02 \x01(\tR\x0espenderAddress\x12\x16\n" +
	"\x06amount\x18\x03 \x01(\tR\x06amount\x12\x1f\n" +
	"\vprivate_key\x18\x04 \x01(\tR\n" +
	"privateKey\"\xc0\x01\n" +
	"\x14ApproveERC20Response\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12#\n" +
	"\rowner_address\x18\x03 \x01(\tR\fownerAddress\x12'\n" +
	"\x0fspender_address\x18\x04 \x01(\tR\x0espenderAddress\x12\x16\n" +
	"\x06amount\x18\x05 \x01(\tR\x06amount\"\x93\x01\n" +
	"\x18GetERC20AllowanceRequest\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12#\n" +
	"\rowner_address\x18\x02 \x01(\tR\fownerAddress\x12'\n" +
	"\x0fspender_address\x18\x03 \x01(\tR\x0espenderAddress\"\xb2\x01\n" +
	"\x19GetERC20AllowanceResponse\x12\x1c\n" +
	"\tallowance\x18\x01 \x01(\tR\tallowance\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12#\n" +
	"\rowner_address\x18\x03 \x01(\tR\fownerAddress\x12'\n" +
	"\x0fspender_address\x18\x04 \x01(\tR\x0espenderAddress\"\xc0\x01\n" +
	"\x18TransferFromERC20Request\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12!\n" +
	"\ffrom_address\x18\x02 \x01(\tR\vfromAddress\x12\x1d\n" +
	"\n" +
	"to_address\x18\x03 \x01(\tR\ttoAddress\x12\x16\n" +
	"\x06amount\x18\x04 \x01(\tR\x06amount\x12\x1f\n" +
	"\vprivate_key\x18\x05 \x01(\tR\n" +
	"privateKey\"\xb9\x01\n" +
	"\x19TransferFromERC20Response\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12!\n" +
	"\ffrom_address\x18\x03 \x01(\tR\vfromAddress\x12\x1d\n" +
	"\n" +
	"to_address\x18\x04 \x01(\tR\ttoAddress\x12\x16\n" +
	"\x06amount\x18\x05 \x01(\tR\x06amount\"\x95\x01\n" +
	"\x10MintERC20Request\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12\x1d\n" +
	"\n" +
	"to_address\x18\x02 \x01(\tR\ttoAddress\x12\x16\n" +
	"\x06amount\x18\x03 \x01(\tR\x06amount\x12\x1f\n" +
	"\vprivate_key\x18\x04 \x01(\tR\n" +
	"privateKey\"\x8e\x01\n" +
	"\x11MintERC20Response\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12\x1d\n" +
	"\n" +
	"to_address\x18\x03 \x01(\tR\ttoAddress\x12\x16\n" +
	"\x06amount\x18\x04 \x01(\tR\x06amount\"v\n" +
	"\x10BurnERC20Request\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\tR\x06amount\x12\x1f\n" +
	"\vprivate_key\x18\x03 \x01(\tR\n" +
	"privateKey\"\x92\x01\n" +
	"\x11BurnERC20Response\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12!\n" +
	"\ffrom_address\x18\x03 \x01(\tR\vfromAddress\x12\x16\n" +
	"\x06amount\x18\x04 \x01(\tR\x06amount\"\x9d\x01\n" +
	"\x14BurnFromERC20Request\x12)\n" +
	"\x10contract_address\x18\x01 \x01(\tR\x0fcontractAddress\x12!\n" +
	"\ffrom_address\x18\x02 \x01(\tR\vfromAddress\x12\x16\n" +
	"\x06amount\x18\x03 \x01(\tR\x06amount\x12\x1f\n" +
	"\vprivate_key\x18\x04 \x01(\tR\n" +
	"privateKey\"\x96\x01\n" +
	"\x15BurnFromERC20Response\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12!\n" +
	"\ffrom_address\x18\x03 \x01(\tR\vfromAddress\x12\x16\n" +
	"\x06amount\x18\x04 \x01(\tR\x06amount\"\xe6\x01\n" +
	"\x12DeployERC20Request\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06symbol\x18\x02 \x01(\tR\x06symbol\x12\x1a\n" +
	"\bdecimals\x18\x03 \x01(\rR\bdecimals\x12%\n" +
	"\x0einitial_supply\x18\x04 \x01(\tR\rinitialSupply\x12\x1f\n" +
	"\vprivate_key\x18\x05 \x01(\tR\n" +
	"privateKey\x12#\n" +
	"\rcontract_type\x18\x06 \x01(\tR\fcontractType\x12\x1b\n" +
	"\tuse_admin\x18\a \x01(\bR\buseAdmin\"\xf3\x01\n" +
	"\x13DeployERC20Response\x12\x17\n" +
	"\atx_hash\x18\x01 \x01(\tR\x06txHash\x12)\n" +
	"\x10contract_address\x18\x02 \x01(\tR\x0fcontractAddress\x12)\n" +
	"\x10deployer_address\x18\x03 \x01(\tR\x0fdeployerAddress\x12\x12\n" +
	"\x04name\x18\x04 \x01(\tR\x04name\x12\x16\n" +
	"\x06symbol\x18\x05 \x01(\tR\x06symbol\x12\x1a\n" +
	"\bdecimals\x18\x06 \x01(\rR\bdecimals\x12%\n" +
	"\x0einitial_supply\x18\a \x01(\tR\rinitialSupply2\xd3\t\n" +
	"\x05ERC20\x12}\n" +
	"\x0fGetERC20Balance\x12$.api.erc20.v1.GetERC20BalanceRequest\x1a%.api.erc20.v1.GetERC20BalanceResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\x12\x15/api/v1/erc20/balance\x12q\n" +
	"\fGetERC20Info\x12!.api.erc20.v1.GetERC20InfoRequest\x1a\".api.erc20.v1.GetERC20InfoResponse\"\x1a\x82\xd3\xe4\x93\x02\x14\x12\x12/api/v1/erc20/info\x12{\n" +
	"\rTransferERC20\x12\".api.erc20.v1.TransferERC20Request\x1a#.api.erc20.v1.TransferERC20Response\"!\x82\xd3\xe4\x93\x02\x1b:\x01*\"\x16/api/v1/erc20/transfer\x12w\n" +
	"\fApproveERC20\x12!.api.erc20.v1.ApproveERC20Request\x1a\".api.erc20.v1.ApproveERC20Response\" \x82\xd3\xe4\x93\x02\x1a:\x01*\"\x15/api/v1/erc20/approve\x12\x85\x01\n" +
	"\x11GetERC20Allowance\x12&.api.erc20.v1.GetERC20AllowanceRequest\x1a'.api.erc20.v1.GetERC20AllowanceResponse\"\x1f\x82\xd3\xe4\x93\x02\x19\x12\x17/api/v1/erc20/allowance\x12\x8c\x01\n" +
	"\x11TransferFromERC20\x12&.api.erc20.v1.TransferFromERC20Request\x1a'.api.erc20.v1.TransferFromERC20Response\"&\x82\xd3\xe4\x93\x02 :\x01*\"\x1b/api/v1/erc20/transfer-from\x12k\n" +
	"\tMintERC20\x12\x1e.api.erc20.v1.MintERC20Request\x1a\x1f.api.erc20.v1.MintERC20Response\"\x1d\x82\xd3\xe4\x93\x02\x17:\x01*\"\x12/api/v1/erc20/mint\x12k\n" +
	"\tBurnERC20\x12\x1e.api.erc20.v1.BurnERC20Request\x1a\x1f.api.erc20.v1.BurnERC20Response\"\x1d\x82\xd3\xe4\x93\x02\x17:\x01*\"\x12/api/v1/erc20/burn\x12|\n" +
	"\rBurnFromERC20\x12\".api.erc20.v1.BurnFromERC20Request\x1a#.api.erc20.v1.BurnFromERC20Response\"\"\x82\xd3\xe4\x93\x02\x1c:\x01*\"\x17/api/v1/erc20/burn-from\x12s\n" +
	"\vDeployERC20\x12 .api.erc20.v1.DeployERC20Request\x1a!.api.erc20.v1.DeployERC20Response\"\x1f\x82\xd3\xe4\x93\x02\x19:\x01*\"\x14/api/v1/erc20/deployB6\n" +
	"\fapi.erc20.v1P\x01Z$eth-contract-service/api/erc20/v1;v1b\x06proto3"

var (
	file_erc20_v1_erc20_proto_rawDescOnce sync.Once
	file_erc20_v1_erc20_proto_rawDescData []byte
)

func file_erc20_v1_erc20_proto_rawDescGZIP() []byte {
	file_erc20_v1_erc20_proto_rawDescOnce.Do(func() {
		file_erc20_v1_erc20_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_erc20_v1_erc20_proto_rawDesc), len(file_erc20_v1_erc20_proto_rawDesc)))
	})
	return file_erc20_v1_erc20_proto_rawDescData
}

var file_erc20_v1_erc20_proto_msgTypes = make([]protoimpl.MessageInfo, 20)
var file_erc20_v1_erc20_proto_goTypes = []any{
	(*GetERC20BalanceRequest)(nil),    // 0: api.erc20.v1.GetERC20BalanceRequest
	(*GetERC20BalanceResponse)(nil),   // 1: api.erc20.v1.GetERC20BalanceResponse
	(*GetERC20InfoRequest)(nil),       // 2: api.erc20.v1.GetERC20InfoRequest
	(*GetERC20InfoResponse)(nil),      // 3: api.erc20.v1.GetERC20InfoResponse
	(*TransferERC20Request)(nil),      // 4: api.erc20.v1.TransferERC20Request
	(*TransferERC20Response)(nil),     // 5: api.erc20.v1.TransferERC20Response
	(*ApproveERC20Request)(nil),       // 6: api.erc20.v1.ApproveERC20Request
	(*ApproveERC20Response)(nil),      // 7: api.erc20.v1.ApproveERC20Response
	(*GetERC20AllowanceRequest)(nil),  // 8: api.erc20.v1.GetERC20AllowanceRequest
	(*GetERC20AllowanceResponse)(nil), // 9: api.erc20.v1.GetERC20AllowanceResponse
	(*TransferFromERC20Request)(nil),  // 10: api.erc20.v1.TransferFromERC20Request
	(*TransferFromERC20Response)(nil), // 11: api.erc20.v1.TransferFromERC20Response
	(*MintERC20Request)(nil),          // 12: api.erc20.v1.MintERC20Request
	(*MintERC20Response)(nil),         // 13: api.erc20.v1.MintERC20Response
	(*BurnERC20Request)(nil),          // 14: api.erc20.v1.BurnERC20Request
	(*BurnERC20Response)(nil),         // 15: api.erc20.v1.BurnERC20Response
	(*BurnFromERC20Request)(nil),      // 16: api.erc20.v1.BurnFromERC20Request
	(*BurnFromERC20Response)(nil),     // 17: api.erc20.v1.BurnFromERC20Response
	(*DeployERC20Request)(nil),        // 18: api.erc20.v1.DeployERC20Request
	(*DeployERC20Response)(nil),       // 19: api.erc20.v1.DeployERC20Response
}
var file_erc20_v1_erc20_proto_depIdxs = []int32{
	0,  // 0: api.erc20.v1.ERC20.GetERC20Balance:input_type -> api.erc20.v1.GetERC20BalanceRequest
	2,  // 1: api.erc20.v1.ERC20.GetERC20Info:input_type -> api.erc20.v1.GetERC20InfoRequest
	4,  // 2: api.erc20.v1.ERC20.TransferERC20:input_type -> api.erc20.v1.TransferERC20Request
	6,  // 3: api.erc20.v1.ERC20.ApproveERC20:input_type -> api.erc20.v1.ApproveERC20Request
	8,  // 4: api.erc20.v1.ERC20.GetERC20Allowance:input_type -> api.erc20.v1.GetERC20AllowanceRequest
	10, // 5: api.erc20.v1.ERC20.TransferFromERC20:input_type -> api.erc20.v1.TransferFromERC20Request
	12, // 6: api.erc20.v1.ERC20.MintERC20:input_type -> api.erc20.v1.MintERC20Request
	14, // 7: api.erc20.v1.ERC20.BurnERC20:input_type -> api.erc20.v1.BurnERC20Request
	16, // 8: api.erc20.v1.ERC20.BurnFromERC20:input_type -> api.erc20.v1.BurnFromERC20Request
	18, // 9: api.erc20.v1.ERC20.DeployERC20:input_type -> api.erc20.v1.DeployERC20Request
	1,  // 10: api.erc20.v1.ERC20.GetERC20Balance:output_type -> api.erc20.v1.GetERC20BalanceResponse
	3,  // 11: api.erc20.v1.ERC20.GetERC20Info:output_type -> api.erc20.v1.GetERC20InfoResponse
	5,  // 12: api.erc20.v1.ERC20.TransferERC20:output_type -> api.erc20.v1.TransferERC20Response
	7,  // 13: api.erc20.v1.ERC20.ApproveERC20:output_type -> api.erc20.v1.ApproveERC20Response
	9,  // 14: api.erc20.v1.ERC20.GetERC20Allowance:output_type -> api.erc20.v1.GetERC20AllowanceResponse
	11, // 15: api.erc20.v1.ERC20.TransferFromERC20:output_type -> api.erc20.v1.TransferFromERC20Response
	13, // 16: api.erc20.v1.ERC20.MintERC20:output_type -> api.erc20.v1.MintERC20Response
	15, // 17: api.erc20.v1.ERC20.BurnERC20:output_type -> api.erc20.v1.BurnERC20Response
	17, // 18: api.erc20.v1.ERC20.BurnFromERC20:output_type -> api.erc20.v1.BurnFromERC20Response
	19, // 19: api.erc20.v1.ERC20.DeployERC20:output_type -> api.erc20.v1.DeployERC20Response
	10, // [10:20] is the sub-list for method output_type
	0,  // [0:10] is the sub-list for method input_type
	0,  // [0:0] is the sub-list for extension type_name
	0,  // [0:0] is the sub-list for extension extendee
	0,  // [0:0] is the sub-list for field type_name
}

func init() { file_erc20_v1_erc20_proto_init() }
func file_erc20_v1_erc20_proto_init() {
	if File_erc20_v1_erc20_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_erc20_v1_erc20_proto_rawDesc), len(file_erc20_v1_erc20_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   20,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_erc20_v1_erc20_proto_goTypes,
		DependencyIndexes: file_erc20_v1_erc20_proto_depIdxs,
		MessageInfos:      file_erc20_v1_erc20_proto_msgTypes,
	}.Build()
	File_erc20_v1_erc20_proto = out.File
	file_erc20_v1_erc20_proto_goTypes = nil
	file_erc20_v1_erc20_proto_depIdxs = nil
}
