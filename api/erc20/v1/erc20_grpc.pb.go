// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: erc20/v1/erc20.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ERC20_GetERC20Balance_FullMethodName   = "/api.erc20.v1.ERC20/GetERC20Balance"
	ERC20_GetERC20Info_FullMethodName      = "/api.erc20.v1.ERC20/GetERC20Info"
	ERC20_TransferERC20_FullMethodName     = "/api.erc20.v1.ERC20/TransferERC20"
	ERC20_ApproveERC20_FullMethodName      = "/api.erc20.v1.ERC20/ApproveERC20"
	ERC20_GetERC20Allowance_FullMethodName = "/api.erc20.v1.ERC20/GetERC20Allowance"
	ERC20_TransferFromERC20_FullMethodName = "/api.erc20.v1.ERC20/TransferFromERC20"
	ERC20_MintERC20_FullMethodName         = "/api.erc20.v1.ERC20/MintERC20"
	ERC20_BurnERC20_FullMethodName         = "/api.erc20.v1.ERC20/BurnERC20"
	ERC20_BurnFromERC20_FullMethodName     = "/api.erc20.v1.ERC20/BurnFromERC20"
	ERC20_DeployERC20_FullMethodName       = "/api.erc20.v1.ERC20/DeployERC20"
)

// ERC20Client is the client API for ERC20 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ERC20 service provides ERC20 token interaction endpoints
type ERC20Client interface {
	// GetERC20Balance returns the ERC20 token balance of the specified address
	GetERC20Balance(ctx context.Context, in *GetERC20BalanceRequest, opts ...grpc.CallOption) (*GetERC20BalanceResponse, error)
	// GetERC20Info returns ERC20 token information (name, symbol, decimals, total supply)
	GetERC20Info(ctx context.Context, in *GetERC20InfoRequest, opts ...grpc.CallOption) (*GetERC20InfoResponse, error)
	// TransferERC20 transfers ERC20 tokens from the caller to the specified address
	TransferERC20(ctx context.Context, in *TransferERC20Request, opts ...grpc.CallOption) (*TransferERC20Response, error)
	// ApproveERC20 approves the spender to spend ERC20 tokens
	ApproveERC20(ctx context.Context, in *ApproveERC20Request, opts ...grpc.CallOption) (*ApproveERC20Response, error)
	// GetERC20Allowance returns the amount of tokens that the spender is allowed to spend
	GetERC20Allowance(ctx context.Context, in *GetERC20AllowanceRequest, opts ...grpc.CallOption) (*GetERC20AllowanceResponse, error)
	// TransferFromERC20 transfers ERC20 tokens from one address to another (requires approval)
	TransferFromERC20(ctx context.Context, in *TransferFromERC20Request, opts ...grpc.CallOption) (*TransferFromERC20Response, error)
	// MintERC20 mints new ERC20 tokens (only for contracts with mint function)
	MintERC20(ctx context.Context, in *MintERC20Request, opts ...grpc.CallOption) (*MintERC20Response, error)
	// BurnERC20 burns ERC20 tokens from the caller's balance
	BurnERC20(ctx context.Context, in *BurnERC20Request, opts ...grpc.CallOption) (*BurnERC20Response, error)
	// BurnFromERC20 burns ERC20 tokens from a specified address (requires approval)
	BurnFromERC20(ctx context.Context, in *BurnFromERC20Request, opts ...grpc.CallOption) (*BurnFromERC20Response, error)
	// DeployERC20 deploys a new ERC20 token contract
	DeployERC20(ctx context.Context, in *DeployERC20Request, opts ...grpc.CallOption) (*DeployERC20Response, error)
}

type eRC20Client struct {
	cc grpc.ClientConnInterface
}

func NewERC20Client(cc grpc.ClientConnInterface) ERC20Client {
	return &eRC20Client{cc}
}

func (c *eRC20Client) GetERC20Balance(ctx context.Context, in *GetERC20BalanceRequest, opts ...grpc.CallOption) (*GetERC20BalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC20BalanceResponse)
	err := c.cc.Invoke(ctx, ERC20_GetERC20Balance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) GetERC20Info(ctx context.Context, in *GetERC20InfoRequest, opts ...grpc.CallOption) (*GetERC20InfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC20InfoResponse)
	err := c.cc.Invoke(ctx, ERC20_GetERC20Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) TransferERC20(ctx context.Context, in *TransferERC20Request, opts ...grpc.CallOption) (*TransferERC20Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferERC20Response)
	err := c.cc.Invoke(ctx, ERC20_TransferERC20_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) ApproveERC20(ctx context.Context, in *ApproveERC20Request, opts ...grpc.CallOption) (*ApproveERC20Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveERC20Response)
	err := c.cc.Invoke(ctx, ERC20_ApproveERC20_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) GetERC20Allowance(ctx context.Context, in *GetERC20AllowanceRequest, opts ...grpc.CallOption) (*GetERC20AllowanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetERC20AllowanceResponse)
	err := c.cc.Invoke(ctx, ERC20_GetERC20Allowance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) TransferFromERC20(ctx context.Context, in *TransferFromERC20Request, opts ...grpc.CallOption) (*TransferFromERC20Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferFromERC20Response)
	err := c.cc.Invoke(ctx, ERC20_TransferFromERC20_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) MintERC20(ctx context.Context, in *MintERC20Request, opts ...grpc.CallOption) (*MintERC20Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MintERC20Response)
	err := c.cc.Invoke(ctx, ERC20_MintERC20_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) BurnERC20(ctx context.Context, in *BurnERC20Request, opts ...grpc.CallOption) (*BurnERC20Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BurnERC20Response)
	err := c.cc.Invoke(ctx, ERC20_BurnERC20_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) BurnFromERC20(ctx context.Context, in *BurnFromERC20Request, opts ...grpc.CallOption) (*BurnFromERC20Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BurnFromERC20Response)
	err := c.cc.Invoke(ctx, ERC20_BurnFromERC20_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eRC20Client) DeployERC20(ctx context.Context, in *DeployERC20Request, opts ...grpc.CallOption) (*DeployERC20Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeployERC20Response)
	err := c.cc.Invoke(ctx, ERC20_DeployERC20_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ERC20Server is the server API for ERC20 service.
// All implementations must embed UnimplementedERC20Server
// for forward compatibility.
//
// ERC20 service provides ERC20 token interaction endpoints
type ERC20Server interface {
	// GetERC20Balance returns the ERC20 token balance of the specified address
	GetERC20Balance(context.Context, *GetERC20BalanceRequest) (*GetERC20BalanceResponse, error)
	// GetERC20Info returns ERC20 token information (name, symbol, decimals, total supply)
	GetERC20Info(context.Context, *GetERC20InfoRequest) (*GetERC20InfoResponse, error)
	// TransferERC20 transfers ERC20 tokens from the caller to the specified address
	TransferERC20(context.Context, *TransferERC20Request) (*TransferERC20Response, error)
	// ApproveERC20 approves the spender to spend ERC20 tokens
	ApproveERC20(context.Context, *ApproveERC20Request) (*ApproveERC20Response, error)
	// GetERC20Allowance returns the amount of tokens that the spender is allowed to spend
	GetERC20Allowance(context.Context, *GetERC20AllowanceRequest) (*GetERC20AllowanceResponse, error)
	// TransferFromERC20 transfers ERC20 tokens from one address to another (requires approval)
	TransferFromERC20(context.Context, *TransferFromERC20Request) (*TransferFromERC20Response, error)
	// MintERC20 mints new ERC20 tokens (only for contracts with mint function)
	MintERC20(context.Context, *MintERC20Request) (*MintERC20Response, error)
	// BurnERC20 burns ERC20 tokens from the caller's balance
	BurnERC20(context.Context, *BurnERC20Request) (*BurnERC20Response, error)
	// BurnFromERC20 burns ERC20 tokens from a specified address (requires approval)
	BurnFromERC20(context.Context, *BurnFromERC20Request) (*BurnFromERC20Response, error)
	// DeployERC20 deploys a new ERC20 token contract
	DeployERC20(context.Context, *DeployERC20Request) (*DeployERC20Response, error)
	mustEmbedUnimplementedERC20Server()
}

// UnimplementedERC20Server must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedERC20Server struct{}

func (UnimplementedERC20Server) GetERC20Balance(context.Context, *GetERC20BalanceRequest) (*GetERC20BalanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC20Balance not implemented")
}
func (UnimplementedERC20Server) GetERC20Info(context.Context, *GetERC20InfoRequest) (*GetERC20InfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC20Info not implemented")
}
func (UnimplementedERC20Server) TransferERC20(context.Context, *TransferERC20Request) (*TransferERC20Response, error) {
	return nil, status.Error(codes.Unimplemented, "method TransferERC20 not implemented")
}
func (UnimplementedERC20Server) ApproveERC20(context.Context, *ApproveERC20Request) (*ApproveERC20Response, error) {
	return nil, status.Error(codes.Unimplemented, "method ApproveERC20 not implemented")
}
func (UnimplementedERC20Server) GetERC20Allowance(context.Context, *GetERC20AllowanceRequest) (*GetERC20AllowanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetERC20Allowance not implemented")
}
func (UnimplementedERC20Server) TransferFromERC20(context.Context, *TransferFromERC20Request) (*TransferFromERC20Response, error) {
	return nil, status.Error(codes.Unimplemented, "method TransferFromERC20 not implemented")
}
func (UnimplementedERC20Server) MintERC20(context.Context, *MintERC20Request) (*MintERC20Response, error) {
	return nil, status.Error(codes.Unimplemented, "method MintERC20 not implemented")
}
func (UnimplementedERC20Server) BurnERC20(context.Context, *BurnERC20Request) (*BurnERC20Response, error) {
	return nil, status.Error(codes.Unimplemented, "method BurnERC20 not implemented")
}
func (UnimplementedERC20Server) BurnFromERC20(context.Context, *BurnFromERC20Request) (*BurnFromERC20Response, error) {
	return nil, status.Error(codes.Unimplemented, "method BurnFromERC20 not implemented")
}
func (UnimplementedERC20Server) DeployERC20(context.Context, *DeployERC20Request) (*DeployERC20Response, error) {
	return nil, status.Error(codes.Unimplemented, "method DeployERC20 not implemented")
}
func (UnimplementedERC20Server) mustEmbedUnimplementedERC20Server() {}
func (UnimplementedERC20Server) testEmbeddedByValue()               {}

// UnsafeERC20Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ERC20Server will
// result in compilation errors.
type UnsafeERC20Server interface {
	mustEmbedUnimplementedERC20Server()
}

func RegisterERC20Server(s grpc.ServiceRegistrar, srv ERC20Server) {
	// If the following call panics, it indicates UnimplementedERC20Server was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ERC20_ServiceDesc, srv)
}

func _ERC20_GetERC20Balance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC20BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).GetERC20Balance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_GetERC20Balance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).GetERC20Balance(ctx, req.(*GetERC20BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_GetERC20Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC20InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).GetERC20Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_GetERC20Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).GetERC20Info(ctx, req.(*GetERC20InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_TransferERC20_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferERC20Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).TransferERC20(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_TransferERC20_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).TransferERC20(ctx, req.(*TransferERC20Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_ApproveERC20_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveERC20Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).ApproveERC20(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_ApproveERC20_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).ApproveERC20(ctx, req.(*ApproveERC20Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_GetERC20Allowance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetERC20AllowanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).GetERC20Allowance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_GetERC20Allowance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).GetERC20Allowance(ctx, req.(*GetERC20AllowanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_TransferFromERC20_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferFromERC20Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).TransferFromERC20(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_TransferFromERC20_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).TransferFromERC20(ctx, req.(*TransferFromERC20Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_MintERC20_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintERC20Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).MintERC20(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_MintERC20_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).MintERC20(ctx, req.(*MintERC20Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_BurnERC20_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BurnERC20Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).BurnERC20(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_BurnERC20_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).BurnERC20(ctx, req.(*BurnERC20Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_BurnFromERC20_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BurnFromERC20Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).BurnFromERC20(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_BurnFromERC20_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).BurnFromERC20(ctx, req.(*BurnFromERC20Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ERC20_DeployERC20_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployERC20Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ERC20Server).DeployERC20(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ERC20_DeployERC20_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ERC20Server).DeployERC20(ctx, req.(*DeployERC20Request))
	}
	return interceptor(ctx, in, info, handler)
}

// ERC20_ServiceDesc is the grpc.ServiceDesc for ERC20 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ERC20_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.erc20.v1.ERC20",
	HandlerType: (*ERC20Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetERC20Balance",
			Handler:    _ERC20_GetERC20Balance_Handler,
		},
		{
			MethodName: "GetERC20Info",
			Handler:    _ERC20_GetERC20Info_Handler,
		},
		{
			MethodName: "TransferERC20",
			Handler:    _ERC20_TransferERC20_Handler,
		},
		{
			MethodName: "ApproveERC20",
			Handler:    _ERC20_ApproveERC20_Handler,
		},
		{
			MethodName: "GetERC20Allowance",
			Handler:    _ERC20_GetERC20Allowance_Handler,
		},
		{
			MethodName: "TransferFromERC20",
			Handler:    _ERC20_TransferFromERC20_Handler,
		},
		{
			MethodName: "MintERC20",
			Handler:    _ERC20_MintERC20_Handler,
		},
		{
			MethodName: "BurnERC20",
			Handler:    _ERC20_BurnERC20_Handler,
		},
		{
			MethodName: "BurnFromERC20",
			Handler:    _ERC20_BurnFromERC20_Handler,
		},
		{
			MethodName: "DeployERC20",
			Handler:    _ERC20_DeployERC20_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "erc20/v1/erc20.proto",
}
