// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v6.33.2
// source: erc1155/v1/erc1155.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationERC1155BurnBatchERC1155 = "/api.erc1155.v1.ERC1155/BurnBatchERC1155"
const OperationERC1155BurnERC1155 = "/api.erc1155.v1.ERC1155/BurnERC1155"
const OperationERC1155DeployERC1155 = "/api.erc1155.v1.ERC1155/DeployERC1155"
const OperationERC1155GetERC1155Balance = "/api.erc1155.v1.ERC1155/GetERC1155Balance"
const OperationERC1155GetERC1155BalancesBatch = "/api.erc1155.v1.ERC1155/GetERC1155BalancesBatch"
const OperationERC1155GetERC1155TokenURI = "/api.erc1155.v1.ERC1155/GetERC1155TokenURI"
const OperationERC1155IsApprovedForAllERC1155 = "/api.erc1155.v1.ERC1155/IsApprovedForAllERC1155"
const OperationERC1155MintBatchERC1155 = "/api.erc1155.v1.ERC1155/MintBatchERC1155"
const OperationERC1155MintERC1155 = "/api.erc1155.v1.ERC1155/MintERC1155"
const OperationERC1155SafeBatchTransferERC1155 = "/api.erc1155.v1.ERC1155/SafeBatchTransferERC1155"
const OperationERC1155SafeTransferERC1155 = "/api.erc1155.v1.ERC1155/SafeTransferERC1155"
const OperationERC1155SetApprovalForAllERC1155 = "/api.erc1155.v1.ERC1155/SetApprovalForAllERC1155"

type ERC1155HTTPServer interface {
	// BurnBatchERC1155 BurnBatchERC1155 burns multiple ERC1155 tokens
	BurnBatchERC1155(context.Context, *BurnBatchERC1155Request) (*BurnBatchERC1155Response, error)
	// BurnERC1155 BurnERC1155 burns ERC1155 tokens
	BurnERC1155(context.Context, *BurnERC1155Request) (*BurnERC1155Response, error)
	// DeployERC1155 DeployERC1155 deploys a new ERC1155 token contract
	DeployERC1155(context.Context, *DeployERC1155Request) (*DeployERC1155Response, error)
	// GetERC1155Balance GetERC1155Balance returns the balance of an address for a specific token ID
	GetERC1155Balance(context.Context, *GetERC1155BalanceRequest) (*GetERC1155BalanceResponse, error)
	// GetERC1155BalancesBatch GetERC1155BalancesBatch returns the balance of multiple addresses for multiple token IDs
	GetERC1155BalancesBatch(context.Context, *GetERC1155BalancesBatchRequest) (*GetERC1155BalancesBatchResponse, error)
	// GetERC1155TokenURI GetERC1155TokenURI returns the URI for a specific token ID
	GetERC1155TokenURI(context.Context, *GetERC1155TokenURIRequest) (*GetERC1155TokenURIResponse, error)
	// IsApprovedForAllERC1155 IsApprovedForAllERC1155 checks if an operator is approved for all tokens of an owner
	IsApprovedForAllERC1155(context.Context, *IsApprovedForAllERC1155Request) (*IsApprovedForAllERC1155Response, error)
	// MintBatchERC1155 MintBatchERC1155 mints multiple ERC1155 tokens
	MintBatchERC1155(context.Context, *MintBatchERC1155Request) (*MintBatchERC1155Response, error)
	// MintERC1155 MintERC1155 mints new ERC1155 tokens
	MintERC1155(context.Context, *MintERC1155Request) (*MintERC1155Response, error)
	// SafeBatchTransferERC1155 SafeBatchTransferERC1155 safely transfers multiple ERC1155 tokens
	SafeBatchTransferERC1155(context.Context, *SafeBatchTransferERC1155Request) (*SafeBatchTransferERC1155Response, error)
	// SafeTransferERC1155 SafeTransferERC1155 transfers an ERC1155 token from one address to another
	SafeTransferERC1155(context.Context, *SafeTransferERC1155Request) (*SafeTransferERC1155Response, error)
	// SetApprovalForAllERC1155 SetApprovalForAllERC1155 enables or disables approval for a third party ("operator") to manage all tokens
	SetApprovalForAllERC1155(context.Context, *SetApprovalForAllERC1155Request) (*SetApprovalForAllERC1155Response, error)
}

func RegisterERC1155HTTPServer(s *http.Server, srv ERC1155HTTPServer) {
	r := s.Route("/")
	r.GET("/api/v1/erc1155/balance", _ERC1155_GetERC1155Balance0_HTTP_Handler(srv))
	r.GET("/api/v1/erc1155/balance-batch", _ERC1155_GetERC1155BalancesBatch0_HTTP_Handler(srv))
	r.GET("/api/v1/erc1155/token-uri", _ERC1155_GetERC1155TokenURI0_HTTP_Handler(srv))
	r.GET("/api/v1/erc1155/is-approved-for-all", _ERC1155_IsApprovedForAllERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/safe-transfer", _ERC1155_SafeTransferERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/safe-batch-transfer", _ERC1155_SafeBatchTransferERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/set-approval-for-all", _ERC1155_SetApprovalForAllERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/mint", _ERC1155_MintERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/mint-batch", _ERC1155_MintBatchERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/burn", _ERC1155_BurnERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/burn-batch", _ERC1155_BurnBatchERC11550_HTTP_Handler(srv))
	r.POST("/api/v1/erc1155/deploy", _ERC1155_DeployERC11550_HTTP_Handler(srv))
}

func _ERC1155_GetERC1155Balance0_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC1155BalanceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155GetERC1155Balance)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC1155Balance(ctx, req.(*GetERC1155BalanceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC1155BalanceResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_GetERC1155BalancesBatch0_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC1155BalancesBatchRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155GetERC1155BalancesBatch)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC1155BalancesBatch(ctx, req.(*GetERC1155BalancesBatchRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC1155BalancesBatchResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_GetERC1155TokenURI0_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetERC1155TokenURIRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155GetERC1155TokenURI)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetERC1155TokenURI(ctx, req.(*GetERC1155TokenURIRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetERC1155TokenURIResponse)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_IsApprovedForAllERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in IsApprovedForAllERC1155Request
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155IsApprovedForAllERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.IsApprovedForAllERC1155(ctx, req.(*IsApprovedForAllERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*IsApprovedForAllERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_SafeTransferERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SafeTransferERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155SafeTransferERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SafeTransferERC1155(ctx, req.(*SafeTransferERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SafeTransferERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_SafeBatchTransferERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SafeBatchTransferERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155SafeBatchTransferERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SafeBatchTransferERC1155(ctx, req.(*SafeBatchTransferERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SafeBatchTransferERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_SetApprovalForAllERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SetApprovalForAllERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155SetApprovalForAllERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SetApprovalForAllERC1155(ctx, req.(*SetApprovalForAllERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SetApprovalForAllERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_MintERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MintERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155MintERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MintERC1155(ctx, req.(*MintERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MintERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_MintBatchERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MintBatchERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155MintBatchERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MintBatchERC1155(ctx, req.(*MintBatchERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MintBatchERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_BurnERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BurnERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155BurnERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BurnERC1155(ctx, req.(*BurnERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BurnERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_BurnBatchERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BurnBatchERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155BurnBatchERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BurnBatchERC1155(ctx, req.(*BurnBatchERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BurnBatchERC1155Response)
		return ctx.Result(200, reply)
	}
}

func _ERC1155_DeployERC11550_HTTP_Handler(srv ERC1155HTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeployERC1155Request
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationERC1155DeployERC1155)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeployERC1155(ctx, req.(*DeployERC1155Request))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeployERC1155Response)
		return ctx.Result(200, reply)
	}
}

type ERC1155HTTPClient interface {
	// BurnBatchERC1155 BurnBatchERC1155 burns multiple ERC1155 tokens
	BurnBatchERC1155(ctx context.Context, req *BurnBatchERC1155Request, opts ...http.CallOption) (rsp *BurnBatchERC1155Response, err error)
	// BurnERC1155 BurnERC1155 burns ERC1155 tokens
	BurnERC1155(ctx context.Context, req *BurnERC1155Request, opts ...http.CallOption) (rsp *BurnERC1155Response, err error)
	// DeployERC1155 DeployERC1155 deploys a new ERC1155 token contract
	DeployERC1155(ctx context.Context, req *DeployERC1155Request, opts ...http.CallOption) (rsp *DeployERC1155Response, err error)
	// GetERC1155Balance GetERC1155Balance returns the balance of an address for a specific token ID
	GetERC1155Balance(ctx context.Context, req *GetERC1155BalanceRequest, opts ...http.CallOption) (rsp *GetERC1155BalanceResponse, err error)
	// GetERC1155BalancesBatch GetERC1155BalancesBatch returns the balance of multiple addresses for multiple token IDs
	GetERC1155BalancesBatch(ctx context.Context, req *GetERC1155BalancesBatchRequest, opts ...http.CallOption) (rsp *GetERC1155BalancesBatchResponse, err error)
	// GetERC1155TokenURI GetERC1155TokenURI returns the URI for a specific token ID
	GetERC1155TokenURI(ctx context.Context, req *GetERC1155TokenURIRequest, opts ...http.CallOption) (rsp *GetERC1155TokenURIResponse, err error)
	// IsApprovedForAllERC1155 IsApprovedForAllERC1155 checks if an operator is approved for all tokens of an owner
	IsApprovedForAllERC1155(ctx context.Context, req *IsApprovedForAllERC1155Request, opts ...http.CallOption) (rsp *IsApprovedForAllERC1155Response, err error)
	// MintBatchERC1155 MintBatchERC1155 mints multiple ERC1155 tokens
	MintBatchERC1155(ctx context.Context, req *MintBatchERC1155Request, opts ...http.CallOption) (rsp *MintBatchERC1155Response, err error)
	// MintERC1155 MintERC1155 mints new ERC1155 tokens
	MintERC1155(ctx context.Context, req *MintERC1155Request, opts ...http.CallOption) (rsp *MintERC1155Response, err error)
	// SafeBatchTransferERC1155 SafeBatchTransferERC1155 safely transfers multiple ERC1155 tokens
	SafeBatchTransferERC1155(ctx context.Context, req *SafeBatchTransferERC1155Request, opts ...http.CallOption) (rsp *SafeBatchTransferERC1155Response, err error)
	// SafeTransferERC1155 SafeTransferERC1155 transfers an ERC1155 token from one address to another
	SafeTransferERC1155(ctx context.Context, req *SafeTransferERC1155Request, opts ...http.CallOption) (rsp *SafeTransferERC1155Response, err error)
	// SetApprovalForAllERC1155 SetApprovalForAllERC1155 enables or disables approval for a third party ("operator") to manage all tokens
	SetApprovalForAllERC1155(ctx context.Context, req *SetApprovalForAllERC1155Request, opts ...http.CallOption) (rsp *SetApprovalForAllERC1155Response, err error)
}

type ERC1155HTTPClientImpl struct {
	cc *http.Client
}

func NewERC1155HTTPClient(client *http.Client) ERC1155HTTPClient {
	return &ERC1155HTTPClientImpl{client}
}

// BurnBatchERC1155 BurnBatchERC1155 burns multiple ERC1155 tokens
func (c *ERC1155HTTPClientImpl) BurnBatchERC1155(ctx context.Context, in *BurnBatchERC1155Request, opts ...http.CallOption) (*BurnBatchERC1155Response, error) {
	var out BurnBatchERC1155Response
	pattern := "/api/v1/erc1155/burn-batch"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155BurnBatchERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// BurnERC1155 BurnERC1155 burns ERC1155 tokens
func (c *ERC1155HTTPClientImpl) BurnERC1155(ctx context.Context, in *BurnERC1155Request, opts ...http.CallOption) (*BurnERC1155Response, error) {
	var out BurnERC1155Response
	pattern := "/api/v1/erc1155/burn"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155BurnERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeployERC1155 DeployERC1155 deploys a new ERC1155 token contract
func (c *ERC1155HTTPClientImpl) DeployERC1155(ctx context.Context, in *DeployERC1155Request, opts ...http.CallOption) (*DeployERC1155Response, error) {
	var out DeployERC1155Response
	pattern := "/api/v1/erc1155/deploy"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155DeployERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC1155Balance GetERC1155Balance returns the balance of an address for a specific token ID
func (c *ERC1155HTTPClientImpl) GetERC1155Balance(ctx context.Context, in *GetERC1155BalanceRequest, opts ...http.CallOption) (*GetERC1155BalanceResponse, error) {
	var out GetERC1155BalanceResponse
	pattern := "/api/v1/erc1155/balance"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC1155GetERC1155Balance))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC1155BalancesBatch GetERC1155BalancesBatch returns the balance of multiple addresses for multiple token IDs
func (c *ERC1155HTTPClientImpl) GetERC1155BalancesBatch(ctx context.Context, in *GetERC1155BalancesBatchRequest, opts ...http.CallOption) (*GetERC1155BalancesBatchResponse, error) {
	var out GetERC1155BalancesBatchResponse
	pattern := "/api/v1/erc1155/balance-batch"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC1155GetERC1155BalancesBatch))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetERC1155TokenURI GetERC1155TokenURI returns the URI for a specific token ID
func (c *ERC1155HTTPClientImpl) GetERC1155TokenURI(ctx context.Context, in *GetERC1155TokenURIRequest, opts ...http.CallOption) (*GetERC1155TokenURIResponse, error) {
	var out GetERC1155TokenURIResponse
	pattern := "/api/v1/erc1155/token-uri"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC1155GetERC1155TokenURI))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// IsApprovedForAllERC1155 IsApprovedForAllERC1155 checks if an operator is approved for all tokens of an owner
func (c *ERC1155HTTPClientImpl) IsApprovedForAllERC1155(ctx context.Context, in *IsApprovedForAllERC1155Request, opts ...http.CallOption) (*IsApprovedForAllERC1155Response, error) {
	var out IsApprovedForAllERC1155Response
	pattern := "/api/v1/erc1155/is-approved-for-all"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationERC1155IsApprovedForAllERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// MintBatchERC1155 MintBatchERC1155 mints multiple ERC1155 tokens
func (c *ERC1155HTTPClientImpl) MintBatchERC1155(ctx context.Context, in *MintBatchERC1155Request, opts ...http.CallOption) (*MintBatchERC1155Response, error) {
	var out MintBatchERC1155Response
	pattern := "/api/v1/erc1155/mint-batch"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155MintBatchERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// MintERC1155 MintERC1155 mints new ERC1155 tokens
func (c *ERC1155HTTPClientImpl) MintERC1155(ctx context.Context, in *MintERC1155Request, opts ...http.CallOption) (*MintERC1155Response, error) {
	var out MintERC1155Response
	pattern := "/api/v1/erc1155/mint"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155MintERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SafeBatchTransferERC1155 SafeBatchTransferERC1155 safely transfers multiple ERC1155 tokens
func (c *ERC1155HTTPClientImpl) SafeBatchTransferERC1155(ctx context.Context, in *SafeBatchTransferERC1155Request, opts ...http.CallOption) (*SafeBatchTransferERC1155Response, error) {
	var out SafeBatchTransferERC1155Response
	pattern := "/api/v1/erc1155/safe-batch-transfer"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155SafeBatchTransferERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SafeTransferERC1155 SafeTransferERC1155 transfers an ERC1155 token from one address to another
func (c *ERC1155HTTPClientImpl) SafeTransferERC1155(ctx context.Context, in *SafeTransferERC1155Request, opts ...http.CallOption) (*SafeTransferERC1155Response, error) {
	var out SafeTransferERC1155Response
	pattern := "/api/v1/erc1155/safe-transfer"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155SafeTransferERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SetApprovalForAllERC1155 SetApprovalForAllERC1155 enables or disables approval for a third party ("operator") to manage all tokens
func (c *ERC1155HTTPClientImpl) SetApprovalForAllERC1155(ctx context.Context, in *SetApprovalForAllERC1155Request, opts ...http.CallOption) (*SetApprovalForAllERC1155Response, error) {
	var out SetApprovalForAllERC1155Response
	pattern := "/api/v1/erc1155/set-approval-for-all"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationERC1155SetApprovalForAllERC1155))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
